

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Docker &mdash; Kubernetes alpha documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/style.css" rel="stylesheet" type="text/css">


  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Kubernetes
          

          
            
            <img src="../../_static/kubernetes-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../container.html">容器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deployment_guide/deployment_guide.html">部署手册</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Kubernetes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Docker</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/container/docker/docker.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="docker">
<h1>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>总体架构<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<img alt="../../_images/docker-architecture.jpg" src="../../_images/docker-architecture.jpg" />
<p>docker 是一个 C/S 模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<ol class="arabic simple">
<li>用户是使用 Docker Client 与 Docker Daemon 建立通讯，并发送请求给后者。</li>
<li>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Server 的功能使其可以接收 Docker Client 的请求。</li>
<li>Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</li>
<li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 graphdriver 将下载镜像以 Graph 的形式存储；</li>
<li>当需要为 Docker 创建网络环境时，通过网络管理驱动 networkdriver 创建并配置 Docker 容器网络环境；</li>
<li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 execdriver 来完成。</li>
<li>libcontainer 是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li>
</ol>
<div class="section" id="docker-client">
<h3>docker Client [发起请求]<a class="headerlink" href="#docker-client" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Docker Client 是和 Docker Daemon 建立通信的客户端。用户使用的可执行文件为 docker（类似可执行脚本的命令），docker 命令后接参数的形式来实现一个完整的请求命令（例如 docker images，docker 为命令可不变，images 为参数可变）。</p>
</li>
<li><p class="first">Docker Client 可以通过以下三种方式和 Docker Daemon 建立通信</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tcp://host:port</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">unix://path_to_socket</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">fd://sockerfd</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Docker Client 发送容器管理请求后，由 Docker Daemon 接受并处理请求，当 Docker Client 接收到返回的请求响应并简单处理后，Docker Client 一次完整的生命周期就结束了。【一次完整的请求：发送请求→处理请求→返回结果】，于传统的C/S架构请求流程并无不同。</p>
</li>
</ol>
</div>
<div class="section" id="docker-daemin">
<h3>Docker Daemin [后台守护进程]<a class="headerlink" href="#docker-daemin" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Docker Daemon 的架构图</p>
<blockquote>
<div><img alt="../../_images/docker-daemon.jpg" src="../../_images/docker-daemon.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">docker Server [调度分发请求]</p>
<blockquote>
<div><ul>
<li><p class="first">Docker Server 的架构图</p>
<blockquote>
<div><img alt="../../_images/docker-server.jpg" src="../../_images/docker-server.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>Docker Server 相当于 C/S 架构的服务端。功能为接收并调度分发 Docker Client 发送的请求。接收请求后，Server 通过路由于分发调度，找到相应的 Handler 并执行请求。</li>
<li>在 Docker 启动过程中，通过包 gorilla/mux，创建一个 mux.Router，提供请求的路由功能。在 Golang 中，gorilla/mux 是一个强大的 URL 路由器以及调度分发器。该 mux.Router 中添加了众多的路由项，每一个路由项由 HTTP 请求方法（PUTPOSTGETDELETE）、URL、Handler 三部分组成</li>
<li>创建完 mux.Router 之后，Docker 将 Server 的监听地址以及 mux.Router 作为参数，创建一个 httpSrv=http.Server{}，最终执行 httpSrv.Server() 为请求服务。</li>
<li>在 Server 的服务过程中，Server 在 Listener 上接受 Docker Client 的访问请求，并创建一个全新的 goroutine 来服务该请求。在 goroutine 中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的 Handler 来处理该请求，最后 Handler 处理完请求之后回复该请求。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Engine</p>
<blockquote>
<div><ol class="arabic simple">
<li>Engine 是 Docker 架构中的运行引擎，同时也是 Docker 运行的核心模块。它扮演 Docker container 存储仓库的角色，并且通过执行 job 的方式来操纵管理这些容器。</li>
<li>在 Engine 数据结构的设计于实现过程中，有一个 handler 对象。该 handler 对象存储的都是关于众多特定 job 的 handler 处理访问。举例说明，Engine 的 handler 对象中有一项为：<code class="docutils literal notranslate"><span class="pre">{&quot;create&quot;:</span> <span class="pre">daemin.ContainerCreate,}</span></code> ，则说明当名为”create“的job在运行是，执行的是 daemon.ContainerCreate 的 handler。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">job</p>
<blockquote>
<div><ol class="arabic simple">
<li>一个 Job 可以认为是 Docker 架构中 Engine 内部最基本的工作执行单元。Docker 可以做的每一项工作，都可以抽象为一个 job。例如：在容器内部运行一个进程，这是一个 job；创建一个新的容器，这是一个 job。Docker Server 的运行过程也是一个 Job，名为 serverapi。</li>
<li>Job 的设计者，把 Job 设计的与 Unix 进程相仿。比如说： job 有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="docker-registry">
<h3>Docker Registry [镜像注册中心]<a class="headerlink" href="#docker-registry" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Docker Registry 是一个存储容器镜像的仓库（注册中心），可以理解为云端镜像仓库，按 repository 来分类，docker pull 按照 [repository]:[tag] 来精确定义一个 image。</li>
<li>在 Docker 的运行过程中，Docker Daemon 会与 Docker Registry 通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的 job 名称分别为 “search”，“pull” 与 “push”</li>
<li>可分为公有仓库（docker hub）和私有仓库</li>
</ol>
</div>
<div class="section" id="graph-docker">
<h3>Graph [docker 内部数据库]<a class="headerlink" href="#graph-docker" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Graph 的架构图</p>
<blockquote>
<div><img alt="../../_images/graph-architecture.jpg" src="../../_images/graph-architecture.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">Repository</p>
<blockquote>
<div><ol class="arabic simple">
<li>已下载镜像的保管者（包括下载镜像和 dockerfile 构建的镜像）</li>
<li>一个 repository 表示某类镜像的仓库（例如 Ubuntu），同一个 repository 内的镜像用 tag 来区分（表示同一类镜像的不同标签或版本）。一个 Registry 包含多个 repository，一个 repository 包含同类型的多个 image。</li>
<li>镜像的存储类型有 aufs，devicemapper，Btrfs，vfs 等。其中 centos 系统使用 devicemapper 的存储类型。</li>
<li>同时在 Graph 的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体 rootfs。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">GraphDB</p>
<blockquote>
<div><ol class="arabic simple">
<li>已下载容器镜像之间关系的记录者。</li>
<li>GraphDB 是一个构建在 SQLite 之上的小型图形数据库，实现了节点的命名以及节点之间关联关系的记录。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="driver">
<h3>Driver [执行部分]<a class="headerlink" href="#driver" title="Permalink to this headline">¶</a></h3>
<p>Driver 是 Docker 架构中的驱动模块。通过 Driver 驱动，Docker 可以实现对 Docker 容器执行环境的定制。即 Graph 负责镜像的存储，Driver 负责容器的执行。</p>
<ol class="arabic">
<li><p class="first">graphdriver</p>
<blockquote>
<div><ul>
<li><p class="first">graphdriver 架构图</p>
<blockquote>
<div><img alt="../../_images/graphdriver.jpg" src="../../_images/graphdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>graphdriver 主要用于完成容器镜像的管理，包括存储与获取。</li>
<li>存储：docker pull 下载的镜像由 graphdriver 存储导本地的指定目录（Graph 中）。</li>
<li>获取：docker run (create) 用镜像来创建容器的时候由 graphdriver 到本地 Graph 中获取镜像。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">networkdriver</p>
<blockquote>
<div><ul>
<li><p class="first">networkdriver 的架构图</p>
<blockquote>
<div><img alt="../../_images/networkdriver.jpg" src="../../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">networkdriver 的用途是完成docker容器网络环境的配置，其中包括：</p>
<blockquote>
<div><ul class="simple">
<li>Docker 启动时为 Docker 环境创建网桥</li>
<li>Docker 容器创建时为其创建专属虚拟网卡设备</li>
<li>Docker 容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">execdriver</p>
<blockquote>
<div><ul>
<li><p class="first">execdriver 的结构图</p>
<blockquote>
<div><img alt="../../_images/execdriver.jpg" src="../../_images/execdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>execdriver 作为 Docker 容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li>
<li>现在 execdriver 默认使用 native 驱动，不依赖于 LXC。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="libcontainer">
<h3>libcontainer [函数库]<a class="headerlink" href="#libcontainer" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">libcontainer 的架构图</p>
<blockquote>
<div><img alt="../../_images/networkdriver.jpg" src="../../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>libcontainer 是 Docker 架构中一个使用 Go 语言设计实现的库，设计初衷时希望该库可以不依靠任何依赖，直接访问内核中于容器相关的 API。</li>
<li>Docker 可以直接调用 libcontainer，而最终操作容器的 namespace、cgroups、apparmor、网络设备以及防火墙规则等。</li>
<li>libcontainer 提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer 屏蔽了 Docker 上层对容器的直接管理。</li>
</ol>
</div>
<div class="section" id="docker-container">
<h3>Docker container [服务交付的最终形式]<a class="headerlink" href="#docker-container" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">container 架构</p>
<blockquote>
<div><img alt="../../_images/container.jpg" src="../../_images/container.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">Docker container（Docker 容器）是Docker架构中服务交付的最终体现形式</p>
</li>
<li><p class="first">Docker 按照用户的需求于指令，定制相应的 Docker 容器</p>
<blockquote>
<div><ul class="simple">
<li>用户通过指定容器镜像，使得 Docker 容器可以自定义 rootfs 等文件系统</li>
<li>用户通过指定计算资源的配额，使得 Docker 容器使用指定的计算资源</li>
<li>用户通过配置网络及其安全策略，使得 Docker 容器拥有独立且安全的网络环境</li>
<li>用户通过指定运行的命令，使得 Docker 容器执行指定的工作</li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="id2">
<h2>基础用法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>安装<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">依赖的基础环境</p>
<blockquote>
<div><ul class="simple">
<li>64 bits CPU</li>
<li>Linux Kernel 3.10+</li>
<li>Linux Kernel cgroups and namespaces</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">CentOS 7+</p>
<blockquote>
<div><ul>
<li><p class="first">“Extras” repository</p>
<blockquote>
<div><p>不建议通过 CentOS 默认仓库安装 Docker，版本过旧</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Docker Daemon</p>
<blockquote>
<div><ul class="simple">
<li>systemctl start docker.service</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>个人推荐使用 daocloud 安装 docker，安装方式详见 <a class="reference external" href="https://download.daocloud.io/Docker_Mirror/Docker">daocloud 产品中心 docker 安装方式</a></p>
</div>
<div class="section" id="id4">
<h3>docker 程序环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>docker 环境配置都可以由 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.guess</span></code> 这个文件所控制。docker 安装后默认没有 daemon.guess 这个配置文件，需要手工创建。</p>
<p>一般情况下，配置文件 daemin.guess 中配置的项目参数，在启动参数中同样适用，有些可能不一样（具体可以查看官方文档），但需要注意的一点，配置文件中如果已经由摸个配置项，则无法在启动参数中增加，会出现冲突的错误。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">如果在 daemon.guess 文件中进行配置，需要 docker 版本高于 1.12.6（在这个版本不生效，1.13.1 以上是生效的）</p>
</div>
<ul>
<li><p class="first">镜像加速器</p>
<blockquote>
<div><div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>// 配置单个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}

// 配置多个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn/&quot;]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">日志</p>
<blockquote>
<div><p>log-level 的有效值包括：</p>
<ul class="simple">
<li>debug</li>
<li>info</li>
<li>warn</li>
<li>error</li>
<li>fatal</li>
</ul>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;debug&quot;: true,
    &quot;log-level&quot;: &quot;info&quot;
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">监控 Prometheus</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/prometheus/#configure-docker">https://docs.docker.com/engine/admin/prometheus/#configure-docker</a></p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;metrics-addr&quot;: &quot;127.0.0.1:9323&quot;,
    &quot;experimental&quot;: true
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">保持容器在线</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option">https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option</a></p>
<p>当 dockerd 进程死掉后，依旧保持容器存活。</p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;live-restore&quot;: true
}
</pre></div>
</div>
<p>Linux 重载 docker daemon</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo <span class="nb">kill</span> -SIGHUP <span class="k">$(</span>pidof dockerd<span class="k">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">设置 镜像、容器、卷 存放目录和驱动</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver">https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver</a></p>
<p>下述两个参数可以单独使用</p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;graph&quot;: &quot;/mnt/docker-data&quot;,
    &quot;storage-driver&quot;: &quot;overlay&quot;
}
</pre></div>
</div>
<p>graph 设置存放目录 —— Docker Root Dir /mnt/docker-data
storage-driver 设置存储驱动 —— Storage Driver overlay</p>
</div></blockquote>
</li>
<li><p class="first">user namespace remap</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon">https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon</a></p>
<p>安全设置：用户空间重映射</p>
<p>userns-remap 的值可以是 如果值字段 只有 一个值，那么该字段表示组。如果需要同时指定 用户和组，需要使用 冒号 分割，格式为 用户:组</p>
<ul>
<li><p class="first">组</p>
</li>
<li><p class="first">用户:组</p>
</li>
<li><p class="first">组 或 用户 的值可以是组或用户的 名称 或 ID</p>
<blockquote>
<div><ul class="simple">
<li>testuser</li>
<li>testuser:testuser</li>
<li>1001</li>
<li>1001:1001</li>
<li>testuser:1001</li>
<li>1001:testuser</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;userns-remap&quot;: &quot;testuser&quot;
}

// 或同时指定 用户和组，且使用 名称和ID
{
    &quot;userns-remap&quot;: &quot;testuser:1001&quot;
}
</pre></div>
</div>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>$ dockerd --userns-remap<span class="o">=</span><span class="s2">&quot;testuser:testuser&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">userns-remap 使用不多，但并不是不重要。目前不是默认启用的原因时因为一些应用会假定 uid 0 的用户拥有特殊能力，从而导致假定失败，然后报错退出。所以如果要启用 user id remap，你要充分测试一下。但是启用 uid remap 的安全性提高是明显的。</p>
</div>
</div></blockquote>
</li>
</ul>
<p>配置完成后我们可以通过命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">info</span></code> 查看 docker 详细信息</p>
</div>
<div class="section" id="id5">
<h3>常用操作<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="24%" />
<col width="6%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">command</th>
<th class="head">content</th>
<th class="head">subobject</th>
<th class="head">subobject content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="4">config</td>
<td rowspan="4">Manage Docker configs</td>
<td>create</td>
<td>Create a configuration file from a file or STDIN as content</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more configuration files</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List configs</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more configuration files</td>
</tr>
<tr class="row-even"><td rowspan="25">container</td>
<td rowspan="25">Manage container</td>
<td>attach</td>
<td>Attach local standard input, output, and error streams to a running container</td>
</tr>
<tr class="row-odd"><td>commit</td>
<td>Create a new image from a container’s changes</td>
</tr>
<tr class="row-even"><td>cp</td>
<td>Copy files/folders between a container and the local filesystem</td>
</tr>
<tr class="row-odd"><td>create</td>
<td>Create a new container</td>
</tr>
<tr class="row-even"><td>diff</td>
<td>Inspect changes to files or directories on a container’s filesystem</td>
</tr>
<tr class="row-odd"><td>exec</td>
<td>Run a command in a running container</td>
</tr>
<tr class="row-even"><td>export</td>
<td>Export a container’s filesystem as a tar archive</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more containers</td>
</tr>
<tr class="row-even"><td>kill</td>
<td>Kill one or more running containers</td>
</tr>
<tr class="row-odd"><td>logs</td>
<td>Fetch the logs of a container</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List containers</td>
</tr>
<tr class="row-odd"><td>pause</td>
<td>Pause all processes whitin one or more containers</td>
</tr>
<tr class="row-even"><td>port</td>
<td>List port mappings or a specific mapping for the container</td>
</tr>
<tr class="row-odd"><td>prune</td>
<td>Remove all stopped containers</td>
</tr>
<tr class="row-even"><td>rename</td>
<td>Rename a container</td>
</tr>
<tr class="row-odd"><td>restart</td>
<td>Restart one or more containers</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more container</td>
</tr>
<tr class="row-odd"><td>run</td>
<td>Run a command in a new container</td>
</tr>
<tr class="row-even"><td>start</td>
<td>Start one or more stopped containers</td>
</tr>
<tr class="row-odd"><td>stars</td>
<td>Display a live stream of container(s) resource usage statistics</td>
</tr>
<tr class="row-even"><td>stop</td>
<td>Stop one or more running containers</td>
</tr>
<tr class="row-odd"><td>top</td>
<td>Display the running processes of a containers</td>
</tr>
<tr class="row-even"><td>unpause</td>
<td>Unpause all processes within one or more containers</td>
</tr>
<tr class="row-odd"><td>update</td>
<td>Update configuration of one or more containers</td>
</tr>
<tr class="row-even"><td>wait</td>
<td>Block until one or more containers stop, then print their exit codes</td>
</tr>
<tr class="row-odd"><td rowspan="12">image</td>
<td rowspan="12">Manage images</td>
<td>build</td>
<td>Build an image from Dockerfile</td>
</tr>
<tr class="row-even"><td>history</td>
<td>Show the history of an image</td>
</tr>
<tr class="row-odd"><td>import</td>
<td>Import the containers from a tarball to create a filesystem image</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on onw or more images</td>
</tr>
<tr class="row-odd"><td>load</td>
<td>Load an image from a tar archive or STDIN</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List images</td>
</tr>
<tr class="row-odd"><td>prune</td>
<td>Remove unused images</td>
</tr>
<tr class="row-even"><td>pull</td>
<td>Pull an image or a repository from a registry</td>
</tr>
<tr class="row-odd"><td>push</td>
<td>Push an image or a repository to a registry</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more images</td>
</tr>
<tr class="row-odd"><td>save</td>
<td>Save one or more images to a tar archive (streamed to STDOUT by default)</td>
</tr>
<tr class="row-even"><td>tag</td>
<td>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</td>
</tr>
<tr class="row-odd"><td rowspan="7">network</td>
<td rowspan="7">Manage networks</td>
<td>connect</td>
<td>Connect a container to a network</td>
</tr>
<tr class="row-even"><td>create</td>
<td>Create a network</td>
</tr>
<tr class="row-odd"><td>disconnect</td>
<td>Disconnect detailed information on one or more networks</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more networks</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List networks</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove all unused networks</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more networks</td>
</tr>
<tr class="row-even"><td rowspan="7">node</td>
<td rowspan="7">Manage Swarm node</td>
<td>deamon</td>
<td>Demote one or more nodes from manager in the swarm</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more nodes</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List nodes in the swarm</td>
</tr>
<tr class="row-odd"><td>promote</td>
<td>Promote one or more nodes to manager in the swarm</td>
</tr>
<tr class="row-even"><td>ps</td>
<td>List tasks running on one or more nodes, defaults to current node</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more nodes from the swarm</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update a node</td>
</tr>
<tr class="row-odd"><td rowspan="10">plugin</td>
<td rowspan="10">Manage plugins</td>
<td>create</td>
<td>Create a plugin from a rootfs and configuration. Plugin data directory must contain config.json and rootfs directory.</td>
</tr>
<tr class="row-even"><td>disable</td>
<td>Disable a plugin</td>
</tr>
<tr class="row-odd"><td>enable</td>
<td>Enable a plugin</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more plugins</td>
</tr>
<tr class="row-odd"><td>install</td>
<td>Install a plugin</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List plugins</td>
</tr>
<tr class="row-odd"><td>push</td>
<td>Push a plugin to a registry</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more plugin</td>
</tr>
<tr class="row-odd"><td>set</td>
<td>Change settings for a plugin</td>
</tr>
<tr class="row-even"><td>upgrade</td>
<td>Upgrade an existing plugin</td>
</tr>
<tr class="row-odd"><td rowspan="4">secret</td>
<td rowspan="4">Manage Docker secrets</td>
<td>create</td>
<td>Create a secret from a file or STDIN as content</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on onw or more secrets</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List secrets</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more secrets</td>
</tr>
<tr class="row-odd"><td rowspan="9">service</td>
<td rowspan="9">Manage service</td>
<td>create</td>
<td>Create a new service</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more services</td>
</tr>
<tr class="row-odd"><td>logs</td>
<td>Fetch the logs of a  service or task</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List services</td>
</tr>
<tr class="row-odd"><td>ps</td>
<td>List the tasks of one or more services</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more services</td>
</tr>
<tr class="row-odd"><td>rollback</td>
<td>Revert changes to a service’s configuration</td>
</tr>
<tr class="row-even"><td>scale</td>
<td>Scale one or multiple replicated services</td>
</tr>
<tr class="row-odd"><td>update</td>
<td>Update a service</td>
</tr>
<tr class="row-even"><td rowspan="9">stack</td>
<td rowspan="9">Manage Docker stacks</td>
<td>create</td>
<td>Create a new service</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more services</td>
</tr>
<tr class="row-even"><td>logs</td>
<td>Fetch the logs of a service or task</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List services</td>
</tr>
<tr class="row-even"><td>ps</td>
<td>List the tasks of one or more services</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more services</td>
</tr>
<tr class="row-even"><td>rollback</td>
<td>Revert changes to a service’s configuration</td>
</tr>
<tr class="row-odd"><td>scale</td>
<td>Scale one or multiple replicated services</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update a services</td>
</tr>
<tr class="row-odd"><td rowspan="8">swarm</td>
<td rowspan="8">Manage Swarm</td>
<td>ca</td>
<td>Display and rotate the root CA</td>
</tr>
<tr class="row-even"><td>init</td>
<td>Initialize a swarm</td>
</tr>
<tr class="row-odd"><td>join</td>
<td>Join a swarm as a node and/or manager</td>
</tr>
<tr class="row-even"><td>join-token</td>
<td>Manager join tokens</td>
</tr>
<tr class="row-odd"><td>leave</td>
<td>Leave the swarm</td>
</tr>
<tr class="row-even"><td>unlock</td>
<td>Unlock swarm</td>
</tr>
<tr class="row-odd"><td>unlock-key</td>
<td>Manage the unlock key</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update the swarm</td>
</tr>
<tr class="row-odd"><td rowspan="4">system</td>
<td rowspan="4">Manage Docker</td>
<td>df</td>
<td>Show docker disk usage</td>
</tr>
<tr class="row-even"><td>events</td>
<td>Get real time events from the server</td>
</tr>
<tr class="row-odd"><td>info</td>
<td>Display system-wide information</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove unused data</td>
</tr>
<tr class="row-odd"><td rowspan="6">trust</td>
<td rowspan="6">Manage trust on Docker images (experimental)</td>
<td>key</td>
<td>Manage keys for signing Docker images (experimental)</td>
</tr>
<tr class="row-even"><td>signer</td>
<td>Manage entities who can sign Docker images (experimental)</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Return low-level information about keys and signatures</td>
</tr>
<tr class="row-even"><td>revoke</td>
<td>Remove trust for an image</td>
</tr>
<tr class="row-odd"><td>sign</td>
<td>Sign an image</td>
</tr>
<tr class="row-even"><td>view</td>
<td>Display detailed information about keys and signatures</td>
</tr>
<tr class="row-odd"><td rowspan="5">volume</td>
<td rowspan="5">Manage volumes</td>
<td>create</td>
<td>Create a volume</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more volumes</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List volumes</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove all unused volumes</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more volumes</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id6">
<h3>状态转换<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<img alt="../../_images/docker_event_stats.jpg" src="../../_images/docker_event_stats.jpg" />
</div>
</div>
<div class="section" id="id7">
<h2>网络模式<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>当你开始大规模使用 Docker 时，你会发现需要了解很多关于网络的知识。Docker 容器需要运行在一台宿主机上，可以是一台物理机（on-premise 数据中心的裸金属服务器），也可以是 on-prem 或云上的一台虚拟机。</p>
<div class="section" id="id8">
<h3>简单的 Docker 架构<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>宿主机和容器的关系是 <code class="docutils literal notranslate"><span class="pre">1:N</span></code> ，这意味着一台宿主机上可以运行多个容器。例如，从 Facebook 的报告来看，取决于机器的能力，每台宿主机上平均可以运行 10 到 40 个容器。另一个数据是：在 Mesosphere，我们发现，在裸金属服务器上的各种负载测试中，每台宿主机上不超过 250 个容器是可能的。</p>
<p>无论你是在单主机上进行部署，还是在集群上部署，你总得和网络打交道：</p>
<ul class="simple">
<li>对于大多数单主机部署来说，问题归结于是使用共享卷进行数据交换，还是使用网络（基于 HTTP 或者其他的）进行数据交换。尽管 Docker 数据卷很容易使用，但也引入了紧耦合，这意味着很难将单主机部署转换为多主机部署。自然地，共享卷的优势是速度。</li>
<li>在多主机部署中，你需要考虑两个方面：单主机上的容器之间如何通信和多主机之间的通信路径是怎样的。性能考量和安全方面都有可能影响你的设计决定。多主机部署通常是很有必要的，原因是单主机的能力有限，也可能是因为需要部署分布式系统，例如 Apache Spark、HDFS 和 Cassandra。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>分布式系统的数据本地化（Distributed Systems and Data Locality）</p>
<p class="last">使用分布式系统（计算或存储）的基本想法是想从并行处理中获利，通常伴随着数据本地化。数据本地化，我指的是将代码转移到数据所在地的原则，而不是传统的、其他的方式。考虑以下的场景：如果你的数据集是 TB 级的，而代码是 MB 级的，那么在集群中移动代码此传输 TB 级数据更高效。除了可以并行处理数据之外，分布式系统还可以提供容错性，因为系统中的一部分可以相对独立地工作。</p>
</div>
<p>简单的说，Docker 网络是原生的容器 SDN 解决方案。总而言之，Docker 网络有四种模式：桥接模式，主机模式，容器模式和无网络模式。我们会详细地讨论主机上的各种网络模式。</p>
<img alt="../../_images/four-network-container-archetypes.png" src="../../_images/four-network-container-archetypes.png" />
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
94bb253e0ddc        bridge              bridge              <span class="nb">local</span>
59d9038bfac5        host                host                <span class="nb">local</span>
920274f49a70        none                null                <span class="nb">local</span>
</pre></div>
</div>
</div>
<div class="section" id="bridge">
<h3>bridge 模式网络<a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h3>
<p>在该模式中，docker 守护进程创建了一个虚拟以太网桥 <code class="docutils literal notranslate"><span class="pre">docker0</span></code> ，附加在其上的任何网卡之间都能自动转发数据包。默认情况下，守护进程会创建一对对等接口，将其中一个接口设置为容器的 eth0 接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都链接到这个内部网络上。同时，守护进程还会从网桥的似有地址空间中分配一个IP地址和子网给该容器。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --name<span class="o">=</span>web01 --detach --publish-all --net<span class="o">=</span>bridge nginx:1.14-alpine
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
7f056ef642b7        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">6</span> seconds ago       Up <span class="m">4</span> seconds        <span class="m">0</span>.0.0.0:32768-&gt;80/tcp   web01
$ docker container inspect web01
...
<span class="s2">&quot;NetworkSettings&quot;</span>: <span class="o">{</span>
    <span class="s2">&quot;Bridge&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;SandboxID&quot;</span>: <span class="s2">&quot;56cb1f03f8eda8c1ce73a764eb36794cd87dbf3cae399d2220b623b1f711678a&quot;</span>,
    <span class="s2">&quot;HairpinMode&quot;</span>: false,
    <span class="s2">&quot;LinkLocalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;Ports&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;80/tcp&quot;</span>: <span class="o">[</span>
            <span class="o">{</span>
                <span class="s2">&quot;HostIp&quot;</span>: <span class="s2">&quot;0.0.0.0&quot;</span>,
                <span class="s2">&quot;HostPort&quot;</span>: <span class="s2">&quot;32768&quot;</span>
            <span class="o">}</span>
        <span class="o">]</span>
    <span class="o">}</span>,
    <span class="s2">&quot;SandboxKey&quot;</span>: <span class="s2">&quot;/var/run/docker/netns/56cb1f03f8ed&quot;</span>,
    <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
    <span class="s2">&quot;SecondaryIPv6Addresses&quot;</span>: null,
    <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
    <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
    <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
    <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
    <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
    <span class="s2">&quot;Networks&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;bridge&quot;</span>: <span class="o">{</span>
            <span class="s2">&quot;IPAMConfig&quot;</span>: null,
            <span class="s2">&quot;Links&quot;</span>: null,
            <span class="s2">&quot;Aliases&quot;</span>: null,
            <span class="s2">&quot;NetworkID&quot;</span>: <span class="s2">&quot;94bb253e0ddcd0f2f7b0037bc51c537d2bdcd5d5a156963fbf1c611c37ae807d&quot;</span>,
            <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
            <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
            <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
            <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
            <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
            <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
            <span class="s2">&quot;DriverOpts&quot;</span>: null
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
...
</pre></div>
</div>
<p>查看 bridge 网桥与容器的接口</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ yum -y install bridge-utils
$ brctl show
bridge name bridge id               STP enabled     interfaces
docker0             <span class="m">8000</span>.02428b0967f8       no              veth20f8faa
</pre></div>
</div>
<p>因为 bridge 模式是 Docker 的默认设置，所以你也可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--detach</span> <span class="pre">--publish-all</span> <span class="pre">--name=web01</span> <span class="pre">nginx:1.14-alpine</span></code> 。如果你没有使用 –publish-all（发布该容器暴露的所有端口）或者 –publish host_port:container_port（发布某个特定的端口），IP 数据包就不能从宿主机之外路由到容器中。</p>
<img alt="../../_images/container_network_mode_bridge.png" src="../../_images/container_network_mode_bridge.png" />
</div>
<div class="section" id="host">
<h3>host 模式<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h3>
<p>该模式将禁用 Docker 容器的网络隔离。因为容器共享了宿主机的网络命名空间，直接暴露再公共网络之中。因此，你需要通过端口映射（port mapping）来进行协调。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --detach --name<span class="o">=</span>web01 --publish-all --net<span class="o">=</span>host nginx:1.14-alpine
882db350e02b9922bd911ce9d1b08cfc085cc7baf1dee2a75fbfeae1fae12cfd
$ ip addr <span class="p">|</span> grep -A <span class="m">2</span> eth0:
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
c5a4c0105f22        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   About a minute ago   Up About a minute                       web01
</pre></div>
</div>
<p>我们进入容器内部查看网卡信息</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container exec --interactive --tty web01 /bin/sh</span>
/ <span class="c1"># ip a</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
    valid_lft forever preferred_lft forever
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP qlen <span class="m">1000</span>
    link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
    valid_lft 314753218sec preferred_lft 314753218sec
    inet6 fe80::d20d:b5ff:fe97:409f/64 scope link
    valid_lft forever preferred_lft forever
<span class="m">3</span>: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="m">1500</span> qdisc noqueue state DOWN
    link/ether <span class="m">02</span>:42:8b:09:67:f8 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.1/16 scope global docker0
    valid_lft forever preferred_lft forever
    inet6 fe80::42:8bff:fe09:67f8/64 scope link
    valid_lft forever preferred_lft forever
/ <span class="c1"># exit</span>
</pre></div>
</div>
<p>我们可以从上例中看到：容器和宿主机具有相同的IP地址 <code class="docutils literal notranslate"><span class="pre">172.19.135.14</span></code></p>
<p>在下图中我们可以看到：当使用 host 模式网络时，容器实际上继承了宿主机的IP地址。该模式比 bridge 模块更快（因为没有路由开销），但是它将容器直接暴露在公共网络中，是有安全隐患的。</p>
<img alt="../../_images/Docker_network_mode_host.png" src="../../_images/Docker_network_mode_host.png" />
</div>
<div class="section" id="container">
<h3>container 模式网络<a class="headerlink" href="#container" title="Permalink to this headline">¶</a></h3>
<p>该模式会重用另一个容器的网络名称空间。通常来说，当你想要自定网络栈时，该模式时很有用的。实际上，该模式也是 Kubernetes 使用的网络模式。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=bridge --name=web01 nginx:1.14-alpine</span>
07d43ffe5f341cb10a46c3be9c71a05ffa5b5004aedb38a6cc975705855b8dd9
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
07d43ffe5f34        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">7</span> seconds ago       Up <span class="m">6</span> seconds        <span class="m">0</span>.0.0.0:32769-&gt;80/tcp   web01
<span class="c1"># docker exec --tty --interactive web01 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu <span class="m">1500</span> qdisc noqueue state UP
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
<span class="c1"># docker run --interactive --tty --net=container:web01 ubuntu:14.04 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
</pre></div>
</div>
<p>结果显示：第二个容器使用 <code class="docutils literal notranslate"><span class="pre">--net=container</span></code> 参数，因此和第一个容器 <code class="docutils literal notranslate"><span class="pre">web01</span></code> 具有相同的ip地址 <code class="docutils literal notranslate"><span class="pre">172.17.0.2</span></code></p>
</div>
<div class="section" id="none">
<h3>none 模式网络<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h3>
<p>该模式将容器放置在它自己的网络中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以上两种情况下时有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）；你希望自定义网络。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=none nginx:1.14-alpine</span>
90e19ccb6938b12c366022411a93f25ecb05a7f6b49dd640bb5a0703068076ab
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
90e19ccb6938        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">12</span> seconds ago      Up <span class="m">10</span> seconds                           gracious_bartik
<span class="c1"># docker container inspect gracious_bartik | grep IPAddress</span>
        <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
        <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
                <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
</pre></div>
</div>
<p>在上面的例子中可以看到，恰如我们所料，网络没有任何配置。</p>
</div>
<div class="section" id="id9">
<h3>其他网络话题<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">分配IP地址</p>
<blockquote>
<div><p>频繁大量的创建和销毁容器时，手动分配IP地址是不能接受的。bridge 模式可以在一定程度上解决这个问题。为了防止本地网络上的 ARP 冲突，Docker Daemon 会根据分配的IP地址生成一个随机的 MAC 地址。</p>
</div></blockquote>
</li>
<li><p class="first">分配端口</p>
<blockquote>
<div><p>你会发现有两大阵营：固定端口分配（fixed-port-allocation）和动态端口分配（dynamically-port-allocation）。每个服务或者应用可以有各自的分配方法，也可以是作为全局的策略，但是你必须做出自己的判断和决定。请记住，bridge 模式中，Docker 会自动分配 UDP 或 TCP 端口，并使其可路由。</p>
</div></blockquote>
</li>
<li><p class="first">网络安全</p>
<blockquote>
<div><p>Docker 可以开启容器间通信（意味着默认配置 <code class="docutils literal notranslate"><span class="pre">--icc=true</span></code> ），也就是说，宿主机上的所有容器可以不接受任何限制地相互通讯，这可能导致拒绝服务攻击。进一步地，Docker 可以通过 <code class="docutils literal notranslate"><span class="pre">--ip_forward</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--iptables</span></code> 两个选项控制容器间、容器和外部世界的通信。你应该了解这些选项的默认值，并让网络组根据公司策略设置 Docker 进程。</p>
<p>另一个网络安全方面是线上加密（on-the-wire encryption），通常是指 RFC 5246 中定义的 TLS/SSL。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id10">
<h3>跨主机网络<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在微服务架构中，多个服务是通过服务注册中心进行管理的，服务需要将自己的IP地址和端口发送给注册中心，这样该服务才能被其他服务感知并调用。但是当服务在 docker 容器内运行时，服务获取到的自身IP是宿主机分配的内部IP（默认情况下会在 172.17.0.0/16 子网下），如 172.17.0.1 这个地址只能在宿主机内部使用（通过 docker0 网桥转发），其他的主机是无法 ping 通地。我们就以服务注册的场景讨论 docker 容器跨主机通信方案。</p>
<ul>
<li><p class="first">端口映射</p>
<blockquote>
<div><p>启动容器时通过 -p 参数将容器内服务监听的端口映射到主机端口中。例如容器运行的 web 服务监听 8080 端口，那么当指定 -p 8080:80 时，外部就可以通过访问宿主机的 80 端口访问到这个 web 服务了。</p>
<p>这种方式有一个很大的缺点：服务器端口是一种稀缺资源，一台主机往往会运行多个容器，它们之间很可能会出现端口冲突的情况，而且就服务注册这个场景而言，容器内的 web 服务是无法主动得到宿主机的ip地址的，因此需要我们在启动容器时通过 Dockerfile 将宿主机IP通过环境变量注入到容器中，然后配置 web 项目使用我们指定的 IP 来注册自身。这种方式显然无法应用于大规模集群部署。</p>
</div></blockquote>
</li>
<li><p class="first">不进行网络隔离，直接使用宿主机网络配置</p>
<blockquote>
<div><p>通过 –net=host 参数可以指定使用该模式。在这种模式下，容器的网络环境并没有通过 Linux 内核的 Network Namespace 进行隔离，在容器内可以自由修改宿主机的网络参数，因此是不安全的，但优点是网络性能损失可以忽略不计。对于我们的场景来说，微服务能够想直接部署一样征程获取到主机IP。</p>
</div></blockquote>
</li>
<li><p class="first">组件 overlay 网络</p>
<blockquote>
<div><p>Overlay 网络其实就是隧道技术，即将一种网络协议包装在另一种协议中传输的技术。Docker 常见的 overlay 网络实现有 flannel，swarm overlay，Open vSwitch 等。它们的工作流程基本都是一样的：通过某种方式保证所有 docker 容器都有全局唯一的 IP，然后把 docker 容器的ip和其他所在宿主机ip的对应关系存放到第三方存储服务中（如 etcd，consul），之后通过在宿主机上修改路由表、创建虚拟网卡的方式，将数据包转发到目标容器所在的宿主机上，最后再由目标宿主机的 docekr0 网桥转发给容器。对 flannel 来说，它的工作原理如下：</p>
<img alt="../../_images/flannel_work.png" src="../../_images/flannel_work.png" />
<p>10.56.78.1 和 10.56.78.2 是局域网内的两台物理机，它们各运行着container01和container02。当container01要访问container02时：</p>
<ol class="arabic simple">
<li>数据包首先到达 docker0，由于 flannel 修改了路由表，docker0 会将其转发给 flannel0</li>
<li>flannel 的守护进程 flanneld 会持续监听flannel 转出的数据包，它首先会到 etcd 中查询 container01 所在的宿主机的 IP(10.56.78.1)，然后将原数据包进行封装（可以使用 UDP 或 vxlan 封装），把目的的IP地址改为对方宿主机IP并交由 eth0</li>
<li>etcd 将新数据包通过网络发到 10.56.78.2</li>
<li>10.56.78.2 的 eth0 收到数据包后转发给 flannel0，由守护进程 flanneld 进行解包，取出原数据包，得到容器IP地址 172.17.0.2，然后转发给 docker0</li>
<li>docker0 将数据包转发至容器进程对应端口</li>
</ol>
<p>至此 container01 就实现了跨主机访问 container02。</p>
<p>oberlay 网络的性能损耗取决于其实现方式，经测试，flannel(vxlan模式)，swarm overlay 实现的损耗几乎与端口映射持平，但是 docker 1.12 版本新加入的 swarm overlay 实现性能损耗高达 60%（swarm overlay 代码实现质量不高）。因此，在生产环境中不建议使用 swarm overlay 方案。</p>
</div></blockquote>
</li>
<li><p class="first">Calico 和 Weave</p>
<blockquote>
<div><p>这两种实现的方式跟 overlay 不太一样，它会把每台宿主机都当成一个路由器使用，数据包在各个主机之间流动最终被投递到目标主机。为了让主机支持路由功能，它们会向路由表中写入大量记录，因此如果集群中的节点太多，路由表记录数过高（超过1万）时性能会出现问题。</p>
<p>虽然实现原理一样，但它们的性能区别还是很大的，Calico 因为使用的是内核特性，能做到在内核态完成路由，因此性能于原生网络非常接近（90%以上），而 Weave 则是在用户态转发数据包，性能比较差，损耗高达 70% 以上。</p>
</div></blockquote>
</li>
<li><p class="first">总结</p>
<blockquote>
<div><p>overlay 方案和 Calico，Weave 由于可以实现容器IP的直接通信，因此在服务注册的场景下都可以正常运行，到那时需要付出一定的性能代价。而端口映射方式则需要强行配置我们的应用使用指定IP，灵活性极差，只适用于小规模的集群部署。而 host 模式则是通过牺牲隔离性来换取最大化网络性能。在实际应用中我们应该根据业务特点来选择最适合的网络方案。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, renkeju.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>