

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>容器 &mdash; Kubernetes alpha documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="部署手册" href="../deployment_guide/deployment_guide.html" />
    <link rel="prev" title="欢迎来到 kubernetes 手册" href="../index.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Kubernetes
          

          
            
            <img src="../_static/kubernetes-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">容器</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">入门</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lxc-linux-container">LXC(LinuX container)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chroot">chroot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-namespace">Linux Namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cgroups">cgroups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-container">Linux container</a></li>
<li class="toctree-l4"><a class="reference internal" href="#union-mount">Union Mount</a></li>
<li class="toctree-l4"><a class="reference internal" href="#oci">OCI</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#docker">Docker</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">总体架构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#docker-client">docker Client [发起请求]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#docker-daemin">Docker Daemin [后台守护进程]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#docker-registry">Docker Registry [镜像注册中心]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#graph-docker">Graph [docker 内部数据库]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver">Driver [执行部分]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#libcontainer">libcontainer [函数库]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#docker-container">Docker container [服务交付的最终形式]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">基础用法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">docker 程序环境</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">常用操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">状态转换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">网络模式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">简单的 Docker 架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge">bridge 模式网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host">host 模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container">container 模式网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#none">none 模式网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">其他网络话题</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">跨主机网络</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../deployment_guide/deployment_guide.html">部署手册</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Kubernetes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>容器</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/container/container.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>容器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>入门<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>谈 Docker 必谈容器（Container），woman简单看看现实世界中容器的概念。</p>
<ul>
<li><p class="first">容器是一种基础工具；泛指任何可以用于容纳其他物品的工具，可以部分或完全封闭，被用于容纳、存储、运输物品；物体可以被放置在容器中，而容器则可以保护内容物；</p>
</li>
<li><p class="first">人类使用容器的历史至少有十万年，甚至可能有数百万年的历史；</p>
</li>
<li><p class="first">容器的类型</p>
<blockquote>
<div><ul class="simple">
<li>瓶 —— 指口部比腹部窄小、颈长的容器</li>
<li>罐 —— 指那些开口较大、一般为近圆筒性的器皿</li>
<li>箱 —— 通常是立方体或圆柱体。形状固定</li>
<li>篮 —— 以条状物编织而成</li>
<li>桶 —— 一种圆柱形的容器</li>
<li>袋 —— 柔性材料制成的容器，形状会受内容物而变化</li>
<li>瓮 —— 通常是指陶制，口小肚大的容器</li>
<li>碗 —— 用来盛载食物的容器</li>
<li>柜 —— 指一个由盒组成的家具</li>
<li>鞘 —— 用于装载刀刃的容器</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="section" id="id3">
<h3>概念<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="section" id="lxc-linux-container">
<h4>LXC(LinuX container)<a class="headerlink" href="#lxc-linux-container" title="Permalink to this headline">¶</a></h4>
<p>虚拟化于容器之间的关系</p>
<img alt="../_images/virtualization_and_container.png" src="../_images/virtualization_and_container.png" />
<p>虚拟化常见的两种形式：</p>
<ul>
<li><p class="first">主机级虚拟化</p>
<blockquote>
<div><ul class="simple">
<li>Type-I —— 寄生架构</li>
<li>Type-II —— 裸金属架构</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">容器级虚拟化</p>
<blockquote>
<div><ul class="simple">
<li>chroot</li>
<li>namespace —— 内核级别的环境隔离</li>
<li>cgroups —— 用户空间的资源分配</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="chroot">
<h4>chroot<a class="headerlink" href="#chroot" title="Permalink to this headline">¶</a></h4>
<p>chroot 是属于 Unix 系统中的初级虚拟化技术，虚拟的是文件系统的目录结果，用于隔离。chroot 也是最早出现的这类技术，1982 年就有了应用，后来者如 FreeBSD 的 Jail 和 Linux 的 LXC 都是 chroot 的增强，最终还无意引出了 docker 技术。</p>
<p>chroot，即 change root directory。在 Linux 系统中，系统默认的目录结构都是以根（root）开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为根目录。</p>
</div>
<div class="section" id="linux-namespace">
<h4>Linux Namespace<a class="headerlink" href="#linux-namespace" title="Permalink to this headline">¶</a></h4>
<p>Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。不知道你是否还记得很早之前的 Unix 有一个叫 chroot 的系统调用（通过修改根目录把用户 jail 导一个特定目录下），chroot 提供了一种简单的隔离模式：chroot 内部的文件系统无法访问外部的内容。Linux Namespace 在此基础商，提供了对 UTS、IPC、mount、PID、network、User 等的隔离机制。</p>
<p>举个例子，我们都知道，Linux 下的超级父亲进程的 PID 是 1，所以，同 chroot 一样，如果我们可以把用户的进程空间 jail 到某个进程分支下，并像 chroot 那样让其下面的进程看到的哪个超级父进程的 PID 为 1，于是就可以达到资源隔离的效果了（不同的 PID namespace 中的进程无法看到彼此）。</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="28%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">分类</th>
<th class="head">系统调用参数</th>
<th class="head">隔离内容</th>
<th class="head">相关内核版本</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Mount namespace</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）</td>
<td>Linux 2.4.19</td>
</tr>
<tr class="row-odd"><td>UTS namespace</td>
<td>CLONE_NEWUTS</td>
<td>主机名和域名</td>
<td>Linux 2.6.19</td>
</tr>
<tr class="row-even"><td>IPC namespace</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存</td>
<td>Linux 2.6.19</td>
</tr>
<tr class="row-odd"><td>PID namespace</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
<td>Liunx 2.6.24</td>
</tr>
<tr class="row-even"><td>Network namespace</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等</td>
<td>始于 Linux 2.6.24 完成于 Linux 2.6.29</td>
</tr>
<tr class="row-odd"><td>User namespace</td>
<td>CLONE_NAWUSER</td>
<td>用户和用户组</td>
<td>始于 Linux 2.6.23 完成于 Linux 3.8</td>
</tr>
</tbody>
</table>
<p>主要是三个系统调用</p>
<ul>
<li><p class="first">clone()</p>
<blockquote>
<div><p>实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</p>
</div></blockquote>
</li>
<li><p class="first">unshare()</p>
<blockquote>
<div><p>使某进程脱离某个 namespace</p>
</div></blockquote>
</li>
<li><p class="first">setns()</p>
<blockquote>
<div><p>把某个进程加入到某个 namespace</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="cgroups">
<h4>cgroups<a class="headerlink" href="#cgroups" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>blkio: 块设备IO</li>
<li>cpu: CPU</li>
<li>cpuacct: CPU 资源使用报告</li>
<li>cpuset: 多处理器平台上的 CPU 集合</li>
<li>devices: 设备访问</li>
<li>freezer: 挂起或恢复任务</li>
<li>memory: 内存用量及报告</li>
<li>perf_event: 对 cgroup 中的任务进行统一性能测试</li>
<li>net_cls: cgroup 总的任务创建的数据报问的类别标识符</li>
</ul>
<p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组（Process groups）所使用的物理资源（如 CPU Memory I/O 等）的机制。2007 年进入 Linux 2.6.24 内核，CGroups 不是全新创造的，它将进程管理从 cpuset 中剥离出来，作者是 Google 的 Paul Menage。CGroups 也是 LXC 为实现虚拟化所使用的资源管理手段。</p>
<ul>
<li><p class="first">CGroup 功能及组成</p>
<blockquote>
<div><p>CGroup 是将任意进程进行分组化管理的 Linux 内核功能。CGroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O 或内存的分配控制等具体的的资源管理功能是通过这个功能来实现的。这些具体的资源管理功能称为 CGroup 子系统或控制器。CGroup 子系统有控制内存的 Memory 控制器、控制进程调度的 CPU 控制器等。运行中的内核可以使用的 CGroup 子系统由 /proc/cgroup 来确认。</p>
<p>CGroup 提供了一个 CGroup 虚拟文件系统，作为进行分组管理和各个子系统设置的用户接口。要使用 CGroup，必须挂载 CGroup 文件系统。这时通过挂载选项指定使用哪个子系统。</p>
</div></blockquote>
</li>
<li><p class="first">CGroup 支持的文件种类</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="5%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">文件名</th>
<th class="head">R/W</th>
<th class="head">用途</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Release_agent</td>
<td>RW</td>
<td>删除分组时执行的命令，这个文件之存在于根分组</td>
</tr>
<tr class="row-odd"><td>Notify_on_release</td>
<td>RW</td>
<td>设置是否执行 release_agent。为 1 时执行</td>
</tr>
<tr class="row-even"><td>Tasks</td>
<td>RW</td>
<td>属于分组的线程TID列表</td>
</tr>
<tr class="row-odd"><td>Cgroup.procs</td>
<td>R</td>
<td>属于分组的进程 PID 列表。仅包括多线程进程的线程 leader 的 TID，这点与 tasks 不同</td>
</tr>
<tr class="row-even"><td>Cgroup.event_control</td>
<td>RW</td>
<td>监视状态变化和分组删除事件的配置文件</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">CGroup 相关概念解释</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">任务（task）</p>
<blockquote>
<div><p>在 cgroups 中，任务就是系统的一个进程</p>
</div></blockquote>
</li>
<li><p class="first">控制族群（control group）</p>
<blockquote>
<div><p>控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。</p>
</div></blockquote>
</li>
<li><p class="first">层级（hierarchy）</p>
<blockquote>
<div><p>控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制；</p>
</div></blockquote>
</li>
<li><p class="first">子系统（subsystem）</p>
<blockquote>
<div><p>一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。</p>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">相互关系</p>
<blockquote>
<div><ol class="arabic simple">
<li>每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup，此 cgroup 在创建层级时自动创建，后面在该层级中创建的 cgroup 都是此 cgroup 的后代）的初始成员。</li>
<li>一个子系统最多智能附加到一个层级</li>
<li>一层级可以附加多个子系统</li>
<li>一个任务可以是多个 cgroup 的成员，但是这些 cgroup 必须在不同的层级</li>
<li>系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup 的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的 cgroup。</li>
</ol>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="linux-container">
<h4>Linux container<a class="headerlink" href="#linux-container" title="Permalink to this headline">¶</a></h4>
<p>LXC 是最早一批完整的把容器技术用一组简易使用的工具和模版，来极大的简化了容器技术使用的一个方案。</p>
<p>LXC 项目给不同配置和用户空间应用提供最小的容器操作样板来管理容器声明周期，LXC 项目这个特性和 Linux 内核模仿机制能够正常启用。</p>
<p>容器技术将应用从主机操作系统上解耦出来，摘录该程序并且使之在任意支持 LXC 的系统上都实现轻便化。用户在这样一个原始和最小库的 Linux 操作系统上可以在容器里运行任何程序（就像在容器里面运行 LAMP 堆栈）。</p>
<p>因为应用程序和工作量是相对独立的，所以用户可以运行多版本的语言，比如 PHP，Python，Ruby，Apache，这些语言都可以共存，隐藏在容器里。实现云计算，就好比时这些例子和工作量都可以灵活的被移动到别的系统，复制，以及快速配置。</p>
<p>生产 Docker 的目的是为了尽可能减少容器中运行的程序，减少到之运行单个程序，并且通过 Docker 来管理这个程序。</p>
<p>有了 Docker，可以从底层应用程序通过 Docker 来配置，网络，存储和编排。</p>
<p>LXC 用正常操作系统环境回避那个问题，并且因此可以快速兼容所有应用程序和工具，以及任意管理和编制层次，来代替虚拟机。</p>
<p>除此之外，Docker 使用层次，禁用存储持久性。LXC 支持 AUFS 层次和覆盖，对 COW 克隆和用 brtfs、ZFS、LVM Thin 快照广泛支持，并且将选择留给用户。LXC 容器技术里的分散存储时绑定安装的，来为用户到达主机或着另一个容器。</p>
<p>Docker 和 LXC 都设置了一个默认的 NAT 网络。另外，Docker 设置一个端口转发到主机上，就会有一个 -p 标记，比如 <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">80:80</span></code> 就是 80 从主机转发到容器。有 NAT，本地主机就可以直接通过IP访问容器，外部服务器需要的时候可以通过 IPTable 规则来简单完成，当外部服务被消耗的时候，只需要端口转发就可以。至于为什么需要这么做，原因目前还不是很明确。</p>
<p>要把事项复合起来，Docker 只给了很少的IP和主机文件控制权，所以不能给容器设备静态IP，这对于IP的分配任务来说有点让人疑惑。我们需要使用 <code class="docutils literal notranslate"><span class="pre">--links</span></code> 标记来链接容器，这个容器中要在被链接的容器中加一个入口在 /etc/ 主机上。</p>
<p>有了 LXC，分配静态IP，动态IP，使用多网络设备就简单多了，可以使用 /etc/hosts 文件，基本上使用 Linux 网络全栈时没有限制的。您希望在主机上链接容器吗？用户使用 GRE，L2TPV3 或者 VXLAN 来快速设置层次，或者使用任意的网络技术。LXC 容器技术可以无缝运行虚拟机运行的一切。</p>
</div>
<div class="section" id="union-mount">
<h4>Union Mount<a class="headerlink" href="#union-mount" title="Permalink to this headline">¶</a></h4>
<p>Docker 联合文件系统 Union File System，它是实现 Docker 镜像的技术基础，是一种轻量级的高性能分层文件系统中的修改进行提交和层层叠加，这个特性使得镜像可以通过分层实现和继承。同时支持将不同目录挂载到同一个虚拟文件系统下。</p>
<p>在 Docker 镜像分为基础镜像和父镜像，没有父镜像的镜像称为基础镜像。用户是基于基础镜像制作各种不同的应用镜像。这些应用镜像共享一个基础镜像层，提高了存储效率。</p>
<p>当用户通过升级程序到新版本，改变了一个 Docker 镜像时，一个新的镜像层会被创建。因此，用户不用替换郑哥原镜像或者完全重新建立新镜像，只需要添加新层即可。在用户分发镜像的时候，也只需要分发被改动的新层内容（增量部分）。这让 Docker 的镜像管理变得十分轻松和快速。</p>
<p>在 Docker 中使用 AUFS（Another Union File System 或 Advanced Multilayered Unification File System）就是一种联合文件系统。AUFS 不仅可以对每一个目录设定制度（Readonly）、读写（Readwrite）和写（Witeout-able）权限，同时 AUFS 也可以支持分层的机制，例如，可以对只读权限部分逻辑上进行增量的修改而不影响只读部分。</p>
<img alt="../_images/Union_Mount.png" src="../_images/Union_Mount.png" />
<p>当 Docker 在利用镜像启动一个容器时，Docker 镜像将分配文件系统，并且挂载一个新的可读写的层给容器，容器将会在这个文件系统中被创建，并且这个可读写的层被添加到镜像中。Docker 目前支持的联合文件系统种类包括 AUFS、Btrfs、VFS 和 DeviceMapper 等。</p>
<ul>
<li><p class="first">AUFS(AnotherUnionFS)</p>
<blockquote>
<div><p>Docker 的 Container 机制和使用是建立在 LXC 基础之上的，然而 LXC 本身存在很多问题，例如难以移动、标准化、模版化、重建、复制等。但这些操作又是 Container 实现快速大规模部署和更新所必备的。</p>
<p>Docker 正是利用AUFS分层技术来实现对 Container 的快速更新和大规模部署，并且在 Docker 中引入了 Storage Driver 技术，实现对外置存储的良好支持。Docker 目前支持 AUFS、VFS、DeviceMapper、对 BTRFS 及 ZFS 引入和支持提供了技术规划。</p>
<p>AUFS 是一种 Union FS，简单来说就是“支持将不同目录挂载到同一个虚拟文件系统下的文件系统”，AUFS 支持为每一个成员目录设定只读（Readonly）、读写（Readwrite）和写（Whiteout-able）权限。Union FS 可以将一个 Readonly 的 Branch 和一个 Writeable 的 Branch 联合在一起挂载在同一个文件系统下。</p>
<p>Live CD 正是基于此可以允许在 OS image 不变的基础上允许用户在其上进行一些写操作。Docker 在 AUFS 上构建的 Container image 也正是如此。</p>
</div></blockquote>
</li>
</ul>
<p>接下来我们从 Linux 启动为例介绍 docker 在 AUFS 特性的运行。前面我们介绍容器演进和技术基础介绍，典型的 Linux 启动到运行需要两个 Filesystem，BootFS 和 RootFS</p>
<p>BootFS 主要包含 Bootloader 和 Kernel，BootLoader 主要是引导加载 Kernel，当 Boot 成功后，Kernel 被加载到内存中 BootFS 就被 Umount 了。</p>
<p>RootFS 包含的就是典型 Linux 系统中 /dev /proc /bin 等标准目录和文件。</p>
<img alt="../_images/AUFS_RootFS.png" src="../_images/AUFS_RootFS.png" />
<p>不同的Linux发行版，BootFS 基本是一致的，RootFS 会有差别，因此不同的发行版可以共享 BootFS。</p>
<img alt="../_images/AUFS_BootFS.png" src="../_images/AUFS_BootFS.png" />
<p>Linux 在启动后，首先将 RootFS 设置为 ReadOnly，进行一系列检查后将其切换为 Readwrite 供用户使用。在 Docker 中，也是利用该技术，然后利用 Union Mount 在 Readonly 的 RootFS 文件系统之上挂载 Readwrite 文件系统。并且向上叠加，使得一组 Readonly 和一个 Readwrite 的结构构成一个 Container 的运行目录、每一个被称作一个文件系统 Layer。</p>
<p>AUFS 的特性，使得每一个对 Readonly 层文件/目录的修改都只会存在与上层的 Writeable 层中。这样由于不存在竞争、而且多个 Container 可以共享 Readonly 文件系统层。在 Docker 中，将 Readonly 的层称作“image”镜像。对于 Container 整体而言，整个 RootFS 变的是 read-write 的，但事实上所有的修改都写入最上层的 writeable 层中，image 不保存用户状态，可以用于模版、重建和复制。</p>
<p>在 Docker 中，上层的 Image 依赖下层的 Image，因此 Docker 中把下层的 Image 称作为 父Image，没有父Image 的 Image 称为 base image。因此，想要从一个 image 启动一个 Container，Docker 会先逐次加载其父imgae直到Base image，用户的进程运行在 Writeable 的文件系统层中。所有父Image中的数据信息以及ID、网络和LXC管理的资源限制、具体 Container的配置等，构成一个 Docker 概念上的 Container。</p>
<p>最后我们总结一些 Docker 优势，采用 AUFS 作为 Docker 的 Container 的文件系统，能够提供的优势只有以下几点。</p>
<p>多个 Container 可以共享父Image 存储，节省存储空间；快速部署 —— 如果要部署多个 Container，Base Image 可以避免多次拷贝，实现快速部署。因为多个 Container 共享 Image，提高多个 Container 中的进程命中缓存内容的几率。相比于 Copy-on-write 类型的FS，Base Image 也是可以挂载为 Writeable 的，可以通过更新 Base Image 而一次性更新其之上的 Container。</p>
</div>
<div class="section" id="oci">
<h4>OCI<a class="headerlink" href="#oci" title="Permalink to this headline">¶</a></h4>
<p>很多人可能觉得 docker 已经成为了容器的事实标准，那我们以它作为标准问题就解决了。事情并没有那么简单，首先是否表示容器完全等同于 docker，不允许存在其他的容器运行时（比如 coreOS 推出的 rkt）；其次容器上层抽象（容器集群调度，比如 kubernetes、mesos 等）和 docker 紧密耦合，docker 接口的变化将会导致它们无法使用。</p>
<p>总的来说，如果容器以 docker 作为标准，那么 docker 接口的变化将导致社区中所有相关工具都要更新，不然就无法使用；如果没有标准，这将导致容器实现的碎片化，出现大量的冲突和冗余。这两种情况都时社区不愿意看到的事情，OCI（Open Container Initiative）就是在这个背景下出现的，它的使命就是推动容器标准化，容器能运行在任何的硬件和系统上，相关的组件也不必绑定在任何的容器运行时上。</p>
<p>OCI 由 docker、coreos 以及其他容器相关公司创建于 2015 年，目前主要有两个标准文档：容器运行时标准（runtime spec）和容器镜像标准（image spec）。</p>
<p>这两个协议通过 OCI runtime filesystem bundle 的标准格式连接在一起，OCI 镜像可以通过工具转换成 bundle，然后 OCI 容器引擎能够识别这个 bundle 来运行容器。</p>
<img alt="../_images/runtime_spec_bundle.jpg" src="../_images/runtime_spec_bundle.jpg" />
<ul>
<li><p class="first">image space</p>
<blockquote>
<div><p>OCI 容器镜像主要包括几块内容</p>
<ul>
<li><p class="first">文件系统</p>
<blockquote>
<div><p>以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer 应该保存那些文件，怎么表示增加、修改和删除的文件等。</p>
</div></blockquote>
</li>
<li><p class="first">config 文件</p>
<blockquote>
<div><p>保存了文件系统的层级信息（每个层级的 hash 值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">inspect</span> <span class="pre">&lt;image_id&gt;</span></code> 看到的内容。</p>
</div></blockquote>
</li>
<li><p class="first">manifest 文件</p>
<blockquote>
<div><p>镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest 文件中保存了很多和当前平台有关的信息。</p>
</div></blockquote>
</li>
<li><p class="first">index 文件</p>
<blockquote>
<div><p>可选的文件，指向不同平台的 manifest 文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">runtime spec</p>
<blockquote>
<div><p>OCI 对容器 runtime 的标准主要是指定容器的运行状态，和 runtime 需要提供的命令。下图可以是同容器状态转换图：</p>
<img alt="../_images/runtime_spec_container_state.jpg" src="../_images/runtime_spec_container_state.jpg" />
<ul>
<li><p class="first">init</p>
<blockquote>
<div><p>这个是我自己添加的状态，并不在标准中，表示没有容器存在的初始状态</p>
</div></blockquote>
</li>
<li><p class="first">creating</p>
<blockquote>
<div><p>使用 <code class="docutils literal notranslate"><span class="pre">create</span></code> 命令创建容器，这个过程称为创建中</p>
</div></blockquote>
</li>
<li><p class="first">created</p>
<blockquote>
<div><p>容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台</p>
</div></blockquote>
</li>
<li><p class="first">running</p>
<blockquote>
<div><p>容器的运行状态，里面的进程处于 UP 状态，正在执行用户设定的任务</p>
</div></blockquote>
</li>
<li><p class="first">stopped</p>
<blockquote>
<div><p>容器运行完成，或者运行出错，或者 <code class="docutils literal notranslate"><span class="pre">stop</span></code> 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除。</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="docker">
<h2>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>总体架构<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<img alt="../_images/docker-architecture.jpg" src="../_images/docker-architecture.jpg" />
<p>docker 是一个 C/S 模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<ol class="arabic simple">
<li>用户是使用 Docker Client 与 Docker Daemon 建立通讯，并发送请求给后者。</li>
<li>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Server 的功能使其可以接收 Docker Client 的请求。</li>
<li>Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</li>
<li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 graphdriver 将下载镜像以 Graph 的形式存储；</li>
<li>当需要为 Docker 创建网络环境时，通过网络管理驱动 networkdriver 创建并配置 Docker 容器网络环境；</li>
<li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 execdriver 来完成。</li>
<li>libcontainer 是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li>
</ol>
<div class="section" id="docker-client">
<h4>docker Client [发起请求]<a class="headerlink" href="#docker-client" title="Permalink to this headline">¶</a></h4>
<ol class="arabic">
<li><p class="first">Docker Client 是和 Docker Daemon 建立通信的客户端。用户使用的可执行文件为 docker（类似可执行脚本的命令），docker 命令后接参数的形式来实现一个完整的请求命令（例如 docker images，docker 为命令可不变，images 为参数可变）。</p>
</li>
<li><p class="first">Docker Client 可以通过以下三种方式和 Docker Daemon 建立通信</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tcp://host:port</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">unix://path_to_socket</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">fd://sockerfd</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Docker Client 发送容器管理请求后，由 Docker Daemon 接受并处理请求，当 Docker Client 接收到返回的请求响应并简单处理后，Docker Client 一次完整的生命周期就结束了。【一次完整的请求：发送请求→处理请求→返回结果】，于传统的C/S架构请求流程并无不同。</p>
</li>
</ol>
</div>
<div class="section" id="docker-daemin">
<h4>Docker Daemin [后台守护进程]<a class="headerlink" href="#docker-daemin" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Docker Daemon 的架构图</p>
<blockquote>
<div><img alt="../_images/docker-daemon.jpg" src="../_images/docker-daemon.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">docker Server [调度分发请求]</p>
<blockquote>
<div><ul>
<li><p class="first">Docker Server 的架构图</p>
<blockquote>
<div><img alt="../_images/docker-server.jpg" src="../_images/docker-server.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>Docker Server 相当于 C/S 架构的服务端。功能为接收并调度分发 Docker Client 发送的请求。接收请求后，Server 通过路由于分发调度，找到相应的 Handler 并执行请求。</li>
<li>在 Docker 启动过程中，通过包 gorilla/mux，创建一个 mux.Router，提供请求的路由功能。在 Golang 中，gorilla/mux 是一个强大的 URL 路由器以及调度分发器。该 mux.Router 中添加了众多的路由项，每一个路由项由 HTTP 请求方法（PUTPOSTGETDELETE）、URL、Handler 三部分组成</li>
<li>创建完 mux.Router 之后，Docker 将 Server 的监听地址以及 mux.Router 作为参数，创建一个 httpSrv=http.Server{}，最终执行 httpSrv.Server() 为请求服务。</li>
<li>在 Server 的服务过程中，Server 在 Listener 上接受 Docker Client 的访问请求，并创建一个全新的 goroutine 来服务该请求。在 goroutine 中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的 Handler 来处理该请求，最后 Handler 处理完请求之后回复该请求。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Engine</p>
<blockquote>
<div><ol class="arabic simple">
<li>Engine 是 Docker 架构中的运行引擎，同时也是 Docker 运行的核心模块。它扮演 Docker container 存储仓库的角色，并且通过执行 job 的方式来操纵管理这些容器。</li>
<li>在 Engine 数据结构的设计于实现过程中，有一个 handler 对象。该 handler 对象存储的都是关于众多特定 job 的 handler 处理访问。举例说明，Engine 的 handler 对象中有一项为：<code class="docutils literal notranslate"><span class="pre">{&quot;create&quot;:</span> <span class="pre">daemin.ContainerCreate,}</span></code> ，则说明当名为”create“的job在运行是，执行的是 daemon.ContainerCreate 的 handler。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">job</p>
<blockquote>
<div><ol class="arabic simple">
<li>一个 Job 可以认为是 Docker 架构中 Engine 内部最基本的工作执行单元。Docker 可以做的每一项工作，都可以抽象为一个 job。例如：在容器内部运行一个进程，这是一个 job；创建一个新的容器，这是一个 job。Docker Server 的运行过程也是一个 Job，名为 serverapi。</li>
<li>Job 的设计者，把 Job 设计的与 Unix 进程相仿。比如说： job 有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="docker-registry">
<h4>Docker Registry [镜像注册中心]<a class="headerlink" href="#docker-registry" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>Docker Registry 是一个存储容器镜像的仓库（注册中心），可以理解为云端镜像仓库，按 repository 来分类，docker pull 按照 [repository]:[tag] 来精确定义一个 image。</li>
<li>在 Docker 的运行过程中，Docker Daemon 会与 Docker Registry 通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的 job 名称分别为 “search”，“pull” 与 “push”</li>
<li>可分为公有仓库（docker hub）和私有仓库</li>
</ol>
</div>
<div class="section" id="graph-docker">
<h4>Graph [docker 内部数据库]<a class="headerlink" href="#graph-docker" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Graph 的架构图</p>
<blockquote>
<div><img alt="../_images/graph-architecture.jpg" src="../_images/graph-architecture.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">Repository</p>
<blockquote>
<div><ol class="arabic simple">
<li>已下载镜像的保管者（包括下载镜像和 dockerfile 构建的镜像）</li>
<li>一个 repository 表示某类镜像的仓库（例如 Ubuntu），同一个 repository 内的镜像用 tag 来区分（表示同一类镜像的不同标签或版本）。一个 Registry 包含多个 repository，一个 repository 包含同类型的多个 image。</li>
<li>镜像的存储类型有 aufs，devicemapper，Btrfs，vfs 等。其中 centos 系统使用 devicemapper 的存储类型。</li>
<li>同时在 Graph 的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体 rootfs。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">GraphDB</p>
<blockquote>
<div><ol class="arabic simple">
<li>已下载容器镜像之间关系的记录者。</li>
<li>GraphDB 是一个构建在 SQLite 之上的小型图形数据库，实现了节点的命名以及节点之间关联关系的记录。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="driver">
<h4>Driver [执行部分]<a class="headerlink" href="#driver" title="Permalink to this headline">¶</a></h4>
<p>Driver 是 Docker 架构中的驱动模块。通过 Driver 驱动，Docker 可以实现对 Docker 容器执行环境的定制。即 Graph 负责镜像的存储，Driver 负责容器的执行。</p>
<ol class="arabic">
<li><p class="first">graphdriver</p>
<blockquote>
<div><ul>
<li><p class="first">graphdriver 架构图</p>
<blockquote>
<div><img alt="../_images/graphdriver.jpg" src="../_images/graphdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>graphdriver 主要用于完成容器镜像的管理，包括存储与获取。</li>
<li>存储：docker pull 下载的镜像由 graphdriver 存储导本地的指定目录（Graph 中）。</li>
<li>获取：docker run (create) 用镜像来创建容器的时候由 graphdriver 到本地 Graph 中获取镜像。</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">networkdriver</p>
<blockquote>
<div><ul>
<li><p class="first">networkdriver 的架构图</p>
<blockquote>
<div><img alt="../_images/networkdriver.jpg" src="../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">networkdriver 的用途是完成docker容器网络环境的配置，其中包括：</p>
<blockquote>
<div><ul class="simple">
<li>Docker 启动时为 Docker 环境创建网桥</li>
<li>Docker 容器创建时为其创建专属虚拟网卡设备</li>
<li>Docker 容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">execdriver</p>
<blockquote>
<div><ul>
<li><p class="first">execdriver 的结构图</p>
<blockquote>
<div><img alt="../_images/execdriver.jpg" src="../_images/execdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>execdriver 作为 Docker 容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li>
<li>现在 execdriver 默认使用 native 驱动，不依赖于 LXC。</li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="libcontainer">
<h4>libcontainer [函数库]<a class="headerlink" href="#libcontainer" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">libcontainer 的架构图</p>
<blockquote>
<div><img alt="../_images/networkdriver.jpg" src="../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li>libcontainer 是 Docker 架构中一个使用 Go 语言设计实现的库，设计初衷时希望该库可以不依靠任何依赖，直接访问内核中于容器相关的 API。</li>
<li>Docker 可以直接调用 libcontainer，而最终操作容器的 namespace、cgroups、apparmor、网络设备以及防火墙规则等。</li>
<li>libcontainer 提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer 屏蔽了 Docker 上层对容器的直接管理。</li>
</ol>
</div>
<div class="section" id="docker-container">
<h4>Docker container [服务交付的最终形式]<a class="headerlink" href="#docker-container" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">container 架构</p>
<blockquote>
<div><img alt="../_images/container.jpg" src="../_images/container.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p class="first">Docker container（Docker 容器）是Docker架构中服务交付的最终体现形式</p>
</li>
<li><p class="first">Docker 按照用户的需求于指令，定制相应的 Docker 容器</p>
<blockquote>
<div><ul class="simple">
<li>用户通过指定容器镜像，使得 Docker 容器可以自定义 rootfs 等文件系统</li>
<li>用户通过指定计算资源的配额，使得 Docker 容器使用指定的计算资源</li>
<li>用户通过配置网络及其安全策略，使得 Docker 容器拥有独立且安全的网络环境</li>
<li>用户通过指定运行的命令，使得 Docker 容器执行指定的工作</li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="id5">
<h3>基础用法<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id6">
<h4>安装<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">依赖的基础环境</p>
<blockquote>
<div><ul class="simple">
<li>64 bits CPU</li>
<li>Linux Kernel 3.10+</li>
<li>Linux Kernel cgroups and namespaces</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">CentOS 7+</p>
<blockquote>
<div><ul>
<li><p class="first">“Extras” repository</p>
<blockquote>
<div><p>不建议通过 CentOS 默认仓库安装 Docker，版本过旧</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Docker Daemon</p>
<blockquote>
<div><ul class="simple">
<li>systemctl start docker.service</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>个人推荐使用 daocloud 安装 docker，安装方式详见 <a class="reference external" href="https://download.daocloud.io/Docker_Mirror/Docker">daocloud 产品中心 docker 安装方式</a></p>
</div>
<div class="section" id="id7">
<h4>docker 程序环境<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>docker 环境配置都可以由 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.guess</span></code> 这个文件所控制。docker 安装后默认没有 daemon.guess 这个配置文件，需要手工创建。</p>
<p>一般情况下，配置文件 daemin.guess 中配置的项目参数，在启动参数中同样适用，有些可能不一样（具体可以查看官方文档），但需要注意的一点，配置文件中如果已经由摸个配置项，则无法在启动参数中增加，会出现冲突的错误。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">如果在 daemon.guess 文件中进行配置，需要 docker 版本高于 1.12.6（在这个版本不生效，1.13.1 以上是生效的）</p>
</div>
<ul>
<li><p class="first">镜像加速器</p>
<blockquote>
<div><div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>// 配置单个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}

// 配置多个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn/&quot;]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">日志</p>
<blockquote>
<div><p>log-level 的有效值包括：</p>
<ul class="simple">
<li>debug</li>
<li>info</li>
<li>warn</li>
<li>error</li>
<li>fatal</li>
</ul>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;debug&quot;: true,
    &quot;log-level&quot;: &quot;info&quot;
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">监控 Prometheus</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/prometheus/#configure-docker">https://docs.docker.com/engine/admin/prometheus/#configure-docker</a></p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;metrics-addr&quot;: &quot;127.0.0.1:9323&quot;,
    &quot;experimental&quot;: true
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">保持容器在线</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option">https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option</a></p>
<p>当 dockerd 进程死掉后，依旧保持容器存活。</p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;live-restore&quot;: true
}
</pre></div>
</div>
<p>Linux 重载 docker daemon</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo <span class="nb">kill</span> -SIGHUP <span class="k">$(</span>pidof dockerd<span class="k">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">设置 镜像、容器、卷 存放目录和驱动</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver">https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver</a></p>
<p>下述两个参数可以单独使用</p>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;graph&quot;: &quot;/mnt/docker-data&quot;,
    &quot;storage-driver&quot;: &quot;overlay&quot;
}
</pre></div>
</div>
<p>graph 设置存放目录 —— Docker Root Dir /mnt/docker-data
storage-driver 设置存储驱动 —— Storage Driver overlay</p>
</div></blockquote>
</li>
<li><p class="first">user namespace remap</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon">https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon</a></p>
<p>安全设置：用户空间重映射</p>
<p>userns-remap 的值可以是 如果值字段 只有 一个值，那么该字段表示组。如果需要同时指定 用户和组，需要使用 冒号 分割，格式为 用户:组</p>
<ul>
<li><p class="first">组</p>
</li>
<li><p class="first">用户:组</p>
</li>
<li><p class="first">组 或 用户 的值可以是组或用户的 名称 或 ID</p>
<blockquote>
<div><ul class="simple">
<li>testuser</li>
<li>testuser:testuser</li>
<li>1001</li>
<li>1001:1001</li>
<li>testuser:1001</li>
<li>1001:testuser</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>{
    &quot;userns-remap&quot;: &quot;testuser&quot;
}

// 或同时指定 用户和组，且使用 名称和ID
{
    &quot;userns-remap&quot;: &quot;testuser:1001&quot;
}
</pre></div>
</div>
<div class="highlight-guess notranslate"><div class="highlight"><pre><span></span>$ dockerd --userns-remap<span class="o">=</span><span class="s2">&quot;testuser:testuser&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">userns-remap 使用不多，但并不是不重要。目前不是默认启用的原因时因为一些应用会假定 uid 0 的用户拥有特殊能力，从而导致假定失败，然后报错退出。所以如果要启用 user id remap，你要充分测试一下。但是启用 uid remap 的安全性提高是明显的。</p>
</div>
</div></blockquote>
</li>
</ul>
<p>配置完成后我们可以通过命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">info</span></code> 查看 docker 详细信息</p>
</div>
<div class="section" id="id8">
<h4>常用操作<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="24%" />
<col width="6%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">command</th>
<th class="head">content</th>
<th class="head">subobject</th>
<th class="head">subobject content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="4">config</td>
<td rowspan="4">Manage Docker configs</td>
<td>create</td>
<td>Create a configuration file from a file or STDIN as content</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more configuration files</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List configs</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more configuration files</td>
</tr>
<tr class="row-even"><td rowspan="25">container</td>
<td rowspan="25">Manage container</td>
<td>attach</td>
<td>Attach local standard input, output, and error streams to a running container</td>
</tr>
<tr class="row-odd"><td>commit</td>
<td>Create a new image from a container’s changes</td>
</tr>
<tr class="row-even"><td>cp</td>
<td>Copy files/folders between a container and the local filesystem</td>
</tr>
<tr class="row-odd"><td>create</td>
<td>Create a new container</td>
</tr>
<tr class="row-even"><td>diff</td>
<td>Inspect changes to files or directories on a container’s filesystem</td>
</tr>
<tr class="row-odd"><td>exec</td>
<td>Run a command in a running container</td>
</tr>
<tr class="row-even"><td>export</td>
<td>Export a container’s filesystem as a tar archive</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more containers</td>
</tr>
<tr class="row-even"><td>kill</td>
<td>Kill one or more running containers</td>
</tr>
<tr class="row-odd"><td>logs</td>
<td>Fetch the logs of a container</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List containers</td>
</tr>
<tr class="row-odd"><td>pause</td>
<td>Pause all processes whitin one or more containers</td>
</tr>
<tr class="row-even"><td>port</td>
<td>List port mappings or a specific mapping for the container</td>
</tr>
<tr class="row-odd"><td>prune</td>
<td>Remove all stopped containers</td>
</tr>
<tr class="row-even"><td>rename</td>
<td>Rename a container</td>
</tr>
<tr class="row-odd"><td>restart</td>
<td>Restart one or more containers</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more container</td>
</tr>
<tr class="row-odd"><td>run</td>
<td>Run a command in a new container</td>
</tr>
<tr class="row-even"><td>start</td>
<td>Start one or more stopped containers</td>
</tr>
<tr class="row-odd"><td>stars</td>
<td>Display a live stream of container(s) resource usage statistics</td>
</tr>
<tr class="row-even"><td>stop</td>
<td>Stop one or more running containers</td>
</tr>
<tr class="row-odd"><td>top</td>
<td>Display the running processes of a containers</td>
</tr>
<tr class="row-even"><td>unpause</td>
<td>Unpause all processes within one or more containers</td>
</tr>
<tr class="row-odd"><td>update</td>
<td>Update configuration of one or more containers</td>
</tr>
<tr class="row-even"><td>wait</td>
<td>Block until one or more containers stop, then print their exit codes</td>
</tr>
<tr class="row-odd"><td rowspan="12">image</td>
<td rowspan="12">Manage images</td>
<td>build</td>
<td>Build an image from Dockerfile</td>
</tr>
<tr class="row-even"><td>history</td>
<td>Show the history of an image</td>
</tr>
<tr class="row-odd"><td>import</td>
<td>Import the containers from a tarball to create a filesystem image</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on onw or more images</td>
</tr>
<tr class="row-odd"><td>load</td>
<td>Load an image from a tar archive or STDIN</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List images</td>
</tr>
<tr class="row-odd"><td>prune</td>
<td>Remove unused images</td>
</tr>
<tr class="row-even"><td>pull</td>
<td>Pull an image or a repository from a registry</td>
</tr>
<tr class="row-odd"><td>push</td>
<td>Push an image or a repository to a registry</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more images</td>
</tr>
<tr class="row-odd"><td>save</td>
<td>Save one or more images to a tar archive (streamed to STDOUT by default)</td>
</tr>
<tr class="row-even"><td>tag</td>
<td>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</td>
</tr>
<tr class="row-odd"><td rowspan="7">network</td>
<td rowspan="7">Manage networks</td>
<td>connect</td>
<td>Connect a container to a network</td>
</tr>
<tr class="row-even"><td>create</td>
<td>Create a network</td>
</tr>
<tr class="row-odd"><td>disconnect</td>
<td>Disconnect detailed information on one or more networks</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more networks</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List networks</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove all unused networks</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more networks</td>
</tr>
<tr class="row-even"><td rowspan="7">node</td>
<td rowspan="7">Manage Swarm node</td>
<td>deamon</td>
<td>Demote one or more nodes from manager in the swarm</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more nodes</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List nodes in the swarm</td>
</tr>
<tr class="row-odd"><td>promote</td>
<td>Promote one or more nodes to manager in the swarm</td>
</tr>
<tr class="row-even"><td>ps</td>
<td>List tasks running on one or more nodes, defaults to current node</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more nodes from the swarm</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update a node</td>
</tr>
<tr class="row-odd"><td rowspan="10">plugin</td>
<td rowspan="10">Manage plugins</td>
<td>create</td>
<td>Create a plugin from a rootfs and configuration. Plugin data directory must contain config.json and rootfs directory.</td>
</tr>
<tr class="row-even"><td>disable</td>
<td>Disable a plugin</td>
</tr>
<tr class="row-odd"><td>enable</td>
<td>Enable a plugin</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more plugins</td>
</tr>
<tr class="row-odd"><td>install</td>
<td>Install a plugin</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List plugins</td>
</tr>
<tr class="row-odd"><td>push</td>
<td>Push a plugin to a registry</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more plugin</td>
</tr>
<tr class="row-odd"><td>set</td>
<td>Change settings for a plugin</td>
</tr>
<tr class="row-even"><td>upgrade</td>
<td>Upgrade an existing plugin</td>
</tr>
<tr class="row-odd"><td rowspan="4">secret</td>
<td rowspan="4">Manage Docker secrets</td>
<td>create</td>
<td>Create a secret from a file or STDIN as content</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on onw or more secrets</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List secrets</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more secrets</td>
</tr>
<tr class="row-odd"><td rowspan="9">service</td>
<td rowspan="9">Manage service</td>
<td>create</td>
<td>Create a new service</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more services</td>
</tr>
<tr class="row-odd"><td>logs</td>
<td>Fetch the logs of a  service or task</td>
</tr>
<tr class="row-even"><td>ls</td>
<td>List services</td>
</tr>
<tr class="row-odd"><td>ps</td>
<td>List the tasks of one or more services</td>
</tr>
<tr class="row-even"><td>rm</td>
<td>Remove one or more services</td>
</tr>
<tr class="row-odd"><td>rollback</td>
<td>Revert changes to a service’s configuration</td>
</tr>
<tr class="row-even"><td>scale</td>
<td>Scale one or multiple replicated services</td>
</tr>
<tr class="row-odd"><td>update</td>
<td>Update a service</td>
</tr>
<tr class="row-even"><td rowspan="9">stack</td>
<td rowspan="9">Manage Docker stacks</td>
<td>create</td>
<td>Create a new service</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Display detailed information on one or more services</td>
</tr>
<tr class="row-even"><td>logs</td>
<td>Fetch the logs of a service or task</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List services</td>
</tr>
<tr class="row-even"><td>ps</td>
<td>List the tasks of one or more services</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more services</td>
</tr>
<tr class="row-even"><td>rollback</td>
<td>Revert changes to a service’s configuration</td>
</tr>
<tr class="row-odd"><td>scale</td>
<td>Scale one or multiple replicated services</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update a services</td>
</tr>
<tr class="row-odd"><td rowspan="8">swarm</td>
<td rowspan="8">Manage Swarm</td>
<td>ca</td>
<td>Display and rotate the root CA</td>
</tr>
<tr class="row-even"><td>init</td>
<td>Initialize a swarm</td>
</tr>
<tr class="row-odd"><td>join</td>
<td>Join a swarm as a node and/or manager</td>
</tr>
<tr class="row-even"><td>join-token</td>
<td>Manager join tokens</td>
</tr>
<tr class="row-odd"><td>leave</td>
<td>Leave the swarm</td>
</tr>
<tr class="row-even"><td>unlock</td>
<td>Unlock swarm</td>
</tr>
<tr class="row-odd"><td>unlock-key</td>
<td>Manage the unlock key</td>
</tr>
<tr class="row-even"><td>update</td>
<td>Update the swarm</td>
</tr>
<tr class="row-odd"><td rowspan="4">system</td>
<td rowspan="4">Manage Docker</td>
<td>df</td>
<td>Show docker disk usage</td>
</tr>
<tr class="row-even"><td>events</td>
<td>Get real time events from the server</td>
</tr>
<tr class="row-odd"><td>info</td>
<td>Display system-wide information</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove unused data</td>
</tr>
<tr class="row-odd"><td rowspan="6">trust</td>
<td rowspan="6">Manage trust on Docker images (experimental)</td>
<td>key</td>
<td>Manage keys for signing Docker images (experimental)</td>
</tr>
<tr class="row-even"><td>signer</td>
<td>Manage entities who can sign Docker images (experimental)</td>
</tr>
<tr class="row-odd"><td>inspect</td>
<td>Return low-level information about keys and signatures</td>
</tr>
<tr class="row-even"><td>revoke</td>
<td>Remove trust for an image</td>
</tr>
<tr class="row-odd"><td>sign</td>
<td>Sign an image</td>
</tr>
<tr class="row-even"><td>view</td>
<td>Display detailed information about keys and signatures</td>
</tr>
<tr class="row-odd"><td rowspan="5">volume</td>
<td rowspan="5">Manage volumes</td>
<td>create</td>
<td>Create a volume</td>
</tr>
<tr class="row-even"><td>inspect</td>
<td>Display detailed information on one or more volumes</td>
</tr>
<tr class="row-odd"><td>ls</td>
<td>List volumes</td>
</tr>
<tr class="row-even"><td>prune</td>
<td>Remove all unused volumes</td>
</tr>
<tr class="row-odd"><td>rm</td>
<td>Remove one or more volumes</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id9">
<h4>状态转换<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/docker_event_stats.jpg" src="../_images/docker_event_stats.jpg" />
</div>
</div>
<div class="section" id="id10">
<h3>网络模式<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>当你开始大规模使用 Docker 时，你会发现需要了解很多关于网络的知识。Docker 容器需要运行在一台宿主机上，可以是一台物理机（on-premise 数据中心的裸金属服务器），也可以是 on-prem 或云上的一台虚拟机。</p>
<div class="section" id="id11">
<h4>简单的 Docker 架构<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>宿主机和容器的关系是 <code class="docutils literal notranslate"><span class="pre">1:N</span></code> ，这意味着一台宿主机上可以运行多个容器。例如，从 Facebook 的报告来看，取决于机器的能力，每台宿主机上平均可以运行 10 到 40 个容器。另一个数据是：在 Mesosphere，我们发现，在裸金属服务器上的各种负载测试中，每台宿主机上不超过 250 个容器是可能的。</p>
<p>无论你是在单主机上进行部署，还是在集群上部署，你总得和网络打交道：</p>
<ul class="simple">
<li>对于大多数单主机部署来说，问题归结于是使用共享卷进行数据交换，还是使用网络（基于 HTTP 或者其他的）进行数据交换。尽管 Docker 数据卷很容易使用，但也引入了紧耦合，这意味着很难将单主机部署转换为多主机部署。自然地，共享卷的优势是速度。</li>
<li>在多主机部署中，你需要考虑两个方面：单主机上的容器之间如何通信和多主机之间的通信路径是怎样的。性能考量和安全方面都有可能影响你的设计决定。多主机部署通常是很有必要的，原因是单主机的能力有限，也可能是因为需要部署分布式系统，例如 Apache Spark、HDFS 和 Cassandra。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>分布式系统的数据本地化（Distributed Systems and Data Locality）</p>
<p class="last">使用分布式系统（计算或存储）的基本想法是想从并行处理中获利，通常伴随着数据本地化。数据本地化，我指的是将代码转移到数据所在地的原则，而不是传统的、其他的方式。考虑以下的场景：如果你的数据集是 TB 级的，而代码是 MB 级的，那么在集群中移动代码此传输 TB 级数据更高效。除了可以并行处理数据之外，分布式系统还可以提供容错性，因为系统中的一部分可以相对独立地工作。</p>
</div>
<p>简单的说，Docker 网络是原生的容器 SDN 解决方案。总而言之，Docker 网络有四种模式：桥接模式，主机模式，容器模式和无网络模式。我们会详细地讨论主机上的各种网络模式。</p>
<img alt="../_images/four-network-container-archetypes.png" src="../_images/four-network-container-archetypes.png" />
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
94bb253e0ddc        bridge              bridge              <span class="nb">local</span>
59d9038bfac5        host                host                <span class="nb">local</span>
920274f49a70        none                null                <span class="nb">local</span>
</pre></div>
</div>
</div>
<div class="section" id="bridge">
<h4>bridge 模式网络<a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h4>
<p>在该模式中，docker 守护进程创建了一个虚拟以太网桥 <code class="docutils literal notranslate"><span class="pre">docker0</span></code> ，附加在其上的任何网卡之间都能自动转发数据包。默认情况下，守护进程会创建一对对等接口，将其中一个接口设置为容器的 eth0 接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都链接到这个内部网络上。同时，守护进程还会从网桥的似有地址空间中分配一个IP地址和子网给该容器。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --name<span class="o">=</span>web01 --detach --publish-all --net<span class="o">=</span>bridge nginx:1.14-alpine
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
7f056ef642b7        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">6</span> seconds ago       Up <span class="m">4</span> seconds        <span class="m">0</span>.0.0.0:32768-&gt;80/tcp   web01
$ docker container inspect web01
...
<span class="s2">&quot;NetworkSettings&quot;</span>: <span class="o">{</span>
    <span class="s2">&quot;Bridge&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;SandboxID&quot;</span>: <span class="s2">&quot;56cb1f03f8eda8c1ce73a764eb36794cd87dbf3cae399d2220b623b1f711678a&quot;</span>,
    <span class="s2">&quot;HairpinMode&quot;</span>: false,
    <span class="s2">&quot;LinkLocalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;Ports&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;80/tcp&quot;</span>: <span class="o">[</span>
            <span class="o">{</span>
                <span class="s2">&quot;HostIp&quot;</span>: <span class="s2">&quot;0.0.0.0&quot;</span>,
                <span class="s2">&quot;HostPort&quot;</span>: <span class="s2">&quot;32768&quot;</span>
            <span class="o">}</span>
        <span class="o">]</span>
    <span class="o">}</span>,
    <span class="s2">&quot;SandboxKey&quot;</span>: <span class="s2">&quot;/var/run/docker/netns/56cb1f03f8ed&quot;</span>,
    <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
    <span class="s2">&quot;SecondaryIPv6Addresses&quot;</span>: null,
    <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
    <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
    <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
    <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
    <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
    <span class="s2">&quot;Networks&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;bridge&quot;</span>: <span class="o">{</span>
            <span class="s2">&quot;IPAMConfig&quot;</span>: null,
            <span class="s2">&quot;Links&quot;</span>: null,
            <span class="s2">&quot;Aliases&quot;</span>: null,
            <span class="s2">&quot;NetworkID&quot;</span>: <span class="s2">&quot;94bb253e0ddcd0f2f7b0037bc51c537d2bdcd5d5a156963fbf1c611c37ae807d&quot;</span>,
            <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
            <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
            <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
            <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
            <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
            <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
            <span class="s2">&quot;DriverOpts&quot;</span>: null
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
...
</pre></div>
</div>
<p>查看 bridge 网桥与容器的接口</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ yum -y install bridge-utils
$ brctl show
bridge name bridge id               STP enabled     interfaces
docker0             <span class="m">8000</span>.02428b0967f8       no              veth20f8faa
</pre></div>
</div>
<p>因为 bridge 模式是 Docker 的默认设置，所以你也可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--detach</span> <span class="pre">--publish-all</span> <span class="pre">--name=web01</span> <span class="pre">nginx:1.14-alpine</span></code> 。如果你没有使用 –publish-all（发布该容器暴露的所有端口）或者 –publish host_port:container_port（发布某个特定的端口），IP 数据包就不能从宿主机之外路由到容器中。</p>
<img alt="../_images/container_network_mode_bridge.png" src="../_images/container_network_mode_bridge.png" />
</div>
<div class="section" id="host">
<h4>host 模式<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h4>
<p>该模式将禁用 Docker 容器的网络隔离。因为容器共享了宿主机的网络命名空间，直接暴露再公共网络之中。因此，你需要通过端口映射（port mapping）来进行协调。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --detach --name<span class="o">=</span>web01 --publish-all --net<span class="o">=</span>host nginx:1.14-alpine
882db350e02b9922bd911ce9d1b08cfc085cc7baf1dee2a75fbfeae1fae12cfd
$ ip addr <span class="p">|</span> grep -A <span class="m">2</span> eth0:
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
c5a4c0105f22        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   About a minute ago   Up About a minute                       web01
</pre></div>
</div>
<p>我们进入容器内部查看网卡信息</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container exec --interactive --tty web01 /bin/sh</span>
/ <span class="c1"># ip a</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
    valid_lft forever preferred_lft forever
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP qlen <span class="m">1000</span>
    link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
    valid_lft 314753218sec preferred_lft 314753218sec
    inet6 fe80::d20d:b5ff:fe97:409f/64 scope link
    valid_lft forever preferred_lft forever
<span class="m">3</span>: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="m">1500</span> qdisc noqueue state DOWN
    link/ether <span class="m">02</span>:42:8b:09:67:f8 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.1/16 scope global docker0
    valid_lft forever preferred_lft forever
    inet6 fe80::42:8bff:fe09:67f8/64 scope link
    valid_lft forever preferred_lft forever
/ <span class="c1"># exit</span>
</pre></div>
</div>
<p>我们可以从上例中看到：容器和宿主机具有相同的IP地址 <code class="docutils literal notranslate"><span class="pre">172.19.135.14</span></code></p>
<p>在下图中我们可以看到：当使用 host 模式网络时，容器实际上继承了宿主机的IP地址。该模式比 bridge 模块更快（因为没有路由开销），但是它将容器直接暴露在公共网络中，是有安全隐患的。</p>
<img alt="../_images/Docker_network_mode_host.png" src="../_images/Docker_network_mode_host.png" />
</div>
<div class="section" id="container">
<h4>container 模式网络<a class="headerlink" href="#container" title="Permalink to this headline">¶</a></h4>
<p>该模式会重用另一个容器的网络名称空间。通常来说，当你想要自定网络栈时，该模式时很有用的。实际上，该模式也是 Kubernetes 使用的网络模式。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=bridge --name=web01 nginx:1.14-alpine</span>
07d43ffe5f341cb10a46c3be9c71a05ffa5b5004aedb38a6cc975705855b8dd9
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
07d43ffe5f34        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">7</span> seconds ago       Up <span class="m">6</span> seconds        <span class="m">0</span>.0.0.0:32769-&gt;80/tcp   web01
<span class="c1"># docker exec --tty --interactive web01 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu <span class="m">1500</span> qdisc noqueue state UP
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
<span class="c1"># docker run --interactive --tty --net=container:web01 ubuntu:14.04 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
</pre></div>
</div>
<p>结果显示：第二个容器使用 <code class="docutils literal notranslate"><span class="pre">--net=container</span></code> 参数，因此和第一个容器 <code class="docutils literal notranslate"><span class="pre">web01</span></code> 具有相同的ip地址 <code class="docutils literal notranslate"><span class="pre">172.17.0.2</span></code></p>
</div>
<div class="section" id="none">
<h4>none 模式网络<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h4>
<p>该模式将容器放置在它自己的网络中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以上两种情况下时有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）；你希望自定义网络。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=none nginx:1.14-alpine</span>
90e19ccb6938b12c366022411a93f25ecb05a7f6b49dd640bb5a0703068076ab
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
90e19ccb6938        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">12</span> seconds ago      Up <span class="m">10</span> seconds                           gracious_bartik
<span class="c1"># docker container inspect gracious_bartik | grep IPAddress</span>
        <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
        <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
                <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
</pre></div>
</div>
<p>在上面的例子中可以看到，恰如我们所料，网络没有任何配置。</p>
</div>
<div class="section" id="id12">
<h4>其他网络话题<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">分配IP地址</p>
<blockquote>
<div><p>频繁大量的创建和销毁容器时，手动分配IP地址是不能接受的。bridge 模式可以在一定程度上解决这个问题。为了防止本地网络上的 ARP 冲突，Docker Daemon 会根据分配的IP地址生成一个随机的 MAC 地址。</p>
</div></blockquote>
</li>
<li><p class="first">分配端口</p>
<blockquote>
<div><p>你会发现有两大阵营：固定端口分配（fixed-port-allocation）和动态端口分配（dynamically-port-allocation）。每个服务或者应用可以有各自的分配方法，也可以是作为全局的策略，但是你必须做出自己的判断和决定。请记住，bridge 模式中，Docker 会自动分配 UDP 或 TCP 端口，并使其可路由。</p>
</div></blockquote>
</li>
<li><p class="first">网络安全</p>
<blockquote>
<div><p>Docker 可以开启容器间通信（意味着默认配置 <code class="docutils literal notranslate"><span class="pre">--icc=true</span></code> ），也就是说，宿主机上的所有容器可以不接受任何限制地相互通讯，这可能导致拒绝服务攻击。进一步地，Docker 可以通过 <code class="docutils literal notranslate"><span class="pre">--ip_forward</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--iptables</span></code> 两个选项控制容器间、容器和外部世界的通信。你应该了解这些选项的默认值，并让网络组根据公司策略设置 Docker 进程。</p>
<p>另一个网络安全方面是线上加密（on-the-wire encryption），通常是指 RFC 5246 中定义的 TLS/SSL。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id13">
<h4>跨主机网络<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>在微服务架构中，多个服务是通过服务注册中心进行管理的，服务需要将自己的IP地址和端口发送给注册中心，这样该服务才能被其他服务感知并调用。但是当服务在 docker 容器内运行时，服务获取到的自身IP是宿主机分配的内部IP（默认情况下会在 172.17.0.0/16 子网下），如 172.17.0.1 这个地址只能在宿主机内部使用（通过 docker0 网桥转发），其他的主机是无法 ping 通地。我们就以服务注册的场景讨论 docker 容器跨主机通信方案。</p>
<ul>
<li><p class="first">端口映射</p>
<blockquote>
<div><p>启动容器时通过 -p 参数将容器内服务监听的端口映射到主机端口中。例如容器运行的 web 服务监听 8080 端口，那么当指定 -p 8080:80 时，外部就可以通过访问宿主机的 80 端口访问到这个 web 服务了。</p>
<p>这种方式有一个很大的缺点：服务器端口是一种稀缺资源，一台主机往往会运行多个容器，它们之间很可能会出现端口冲突的情况，而且就服务注册这个场景而言，容器内的 web 服务是无法主动得到宿主机的ip地址的，因此需要我们在启动容器时通过 Dockerfile 将宿主机IP通过环境变量注入到容器中，然后配置 web 项目使用我们指定的 IP 来注册自身。这种方式显然无法应用于大规模集群部署。</p>
</div></blockquote>
</li>
<li><p class="first">不进行网络隔离，直接使用宿主机网络配置</p>
<blockquote>
<div><p>通过 –net=host 参数可以指定使用该模式。在这种模式下，容器的网络环境并没有通过 Linux 内核的 Network Namespace 进行隔离，在容器内可以自由修改宿主机的网络参数，因此是不安全的，但优点是网络性能损失可以忽略不计。对于我们的场景来说，微服务能够想直接部署一样征程获取到主机IP。</p>
</div></blockquote>
</li>
<li><p class="first">组件 overlay 网络</p>
<blockquote>
<div><p>Overlay 网络其实就是隧道技术，即将一种网络协议包装在另一种协议中传输的技术。Docker 常见的 overlay 网络实现有 flannel，swarm overlay，Open vSwitch 等。它们的工作流程基本都是一样的：通过某种方式保证所有 docker 容器都有全局唯一的 IP，然后把 docker 容器的ip和其他所在宿主机ip的对应关系存放到第三方存储服务中（如 etcd，consul），之后通过在宿主机上修改路由表、创建虚拟网卡的方式，将数据包转发到目标容器所在的宿主机上，最后再由目标宿主机的 docekr0 网桥转发给容器。对 flannel 来说，它的工作原理如下：</p>
<img alt="../_images/flannel_work.png" src="../_images/flannel_work.png" />
<p>10.56.78.1 和 10.56.78.2 是局域网内的两台物理机，它们各运行着container01和container02。当container01要访问container02时：</p>
<ol class="arabic simple">
<li>数据包首先到达 docker0，由于 flannel 修改了路由表，docker0 会将其转发给 flannel0</li>
<li>flannel 的守护进程 flanneld 会持续监听flannel 转出的数据包，它首先会到 etcd 中查询 container01 所在的宿主机的 IP(10.56.78.1)，然后将原数据包进行封装（可以使用 UDP 或 vxlan 封装），把目的的IP地址改为对方宿主机IP并交由 eth0</li>
<li>etcd 将新数据包通过网络发到 10.56.78.2</li>
<li>10.56.78.2 的 eth0 收到数据包后转发给 flannel0，由守护进程 flanneld 进行解包，取出原数据包，得到容器IP地址 172.17.0.2，然后转发给 docker0</li>
<li>docker0 将数据包转发至容器进程对应端口</li>
</ol>
<p>至此 container01 就实现了跨主机访问 container02。</p>
<p>oberlay 网络的性能损耗取决于其实现方式，经测试，flannel(vxlan模式)，swarm overlay 实现的损耗几乎与端口映射持平，但是 docker 1.12 版本新加入的 swarm overlay 实现性能损耗高达 60%（swarm overlay 代码实现质量不高）。因此，在生产环境中不建议使用 swarm overlay 方案。</p>
</div></blockquote>
</li>
<li><p class="first">Calico 和 Weave</p>
<blockquote>
<div><p>这两种实现的方式跟 overlay 不太一样，它会把每台宿主机都当成一个路由器使用，数据包在各个主机之间流动最终被投递到目标主机。为了让主机支持路由功能，它们会向路由表中写入大量记录，因此如果集群中的节点太多，路由表记录数过高（超过1万）时性能会出现问题。</p>
<p>虽然实现原理一样，但它们的性能区别还是很大的，Calico 因为使用的是内核特性，能做到在内核态完成路由，因此性能于原生网络非常接近（90%以上），而 Weave 则是在用户态转发数据包，性能比较差，损耗高达 70% 以上。</p>
</div></blockquote>
</li>
<li><p class="first">总结</p>
<blockquote>
<div><p>overlay 方案和 Calico，Weave 由于可以实现容器IP的直接通信，因此在服务注册的场景下都可以正常运行，到那时需要付出一定的性能代价。而端口映射方式则需要强行配置我们的应用使用指定IP，灵活性极差，只适用于小规模的集群部署。而 host 模式则是通过牺牲隔离性来换取最大化网络性能。在实际应用中我们应该根据业务特点来选择最适合的网络方案。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../deployment_guide/deployment_guide.html" class="btn btn-neutral float-right" title="部署手册" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../index.html" class="btn btn-neutral" title="欢迎来到 kubernetes 手册" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, renkeju.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>